<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:local="urn:local-functions"
      xmlns:rsiwp="http://reallysi.com/namespaces/generic-wordprocessing-xml"
      xmlns:stylemap="urn:public:dita4publishers.org:namespaces:word2dita:style2tagmap"
      xmlns:relpath="http://dita2indesign/functions/relpath"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      
      exclude-result-prefixes="xs rsiwp stylemap local relpath xsi"
      version="2.0">

  <!--==========================================
    Simple Word Processing Markup to DITA generic transformation
    
    Copyright (c) 2009, 2012 DITA For Publishers, Inc.

    Transforms a simple word processing document into a DITA topic using
    a style-to-tag mapping.
    
    This transform is intended to be the base for more specialized
    transforms that provide style-specific overrides.
    
    The input to this transform is a simple ML document created
    by transforming some proprietary word processing or DTP
    format, such as DOCX or IDML.
    
    This transform is intended to be used from a format-specific shell
    that generates the simple ML instance and then applies
    this transform. The shell should supply the root template.
       
    Originally developed by Really Strategies, Inc.
    
    =========================================== -->

<!-- 
  The root importer of this module must also import the following module:
  
  
  <xsl:import href="../../net.sourceforge.dita4publishers.common.xslt/xsl/lib/relpath_util.xsl"/>
 -->  
  
  <!-- Paragraphs indexed by the first child bookmark that doesn't have a name starting with "_" 
       Names starting with "_" appear to be autogenerated for TOCs and whatnot.
       Not sure this logic is foolproof. May just have to look up paragraphs directly without
       using a key table.
       
       Adding a prefix to the @name value to make it clearer that we're talking about bookmark
       labels, which in Word may be just simple numbers. The Wordml2simple process does the same
       thing.
    -->
  
  <xsl:key name="bookmarksByName" match="rsiwp:bookmarkStart" use="@name"/>
  
  <xsl:template match="rsiwp:document">
    <xsl:message> + [INFO] simple2dita: Processing intermediate simpleML XML to generate DITA XML...</xsl:message>
    
    <!-- Capture the input document so we can pass it around into contexts where the original
         document context gets lost.
      -->
    <xsl:variable name="simpleWpDoc" as="document-node()" select="root(.)"/>
    <!-- First <p> in doc should be title for the root topic. If it's not, bail -->  
    <xsl:variable name="firstP" select="rsiwp:body/(rsiwp:p|rsiwp:table)[1]" as="element()?"/>
    <xsl:if test="$debugBoolean">        
      <xsl:message> + [DEBUG] rsiwp:document: firstP=<xsl:sequence select="$firstP"/></xsl:message>
    </xsl:if>
    <xsl:if test="$firstP and not(local:isRootTopicTitle($firstP)) and not(local:isMap($firstP))">
      <xsl:message terminate="yes"> - [ERROR] The first block in the Word document must be mapped to the root map or topic title.
        First para is style <xsl:sequence select="string($firstP/@style)"/>, mapped as <xsl:sequence 
          select="
          (key('styleMapsByName', lower-case(string($firstP/@style)), $styleMapDoc)[1],
          key('styleMapsById', string($firstP/@style), $styleMapDoc)[1])[1]"/> 
      </xsl:message>
    </xsl:if>
    <xsl:message> + [INFO] Determining result documents...</xsl:message>
    <xsl:variable name="resultDocs" as="document-node()">
      <xsl:document>
        <xsl:choose>
          <xsl:when test="local:isMap($firstP) or local:isMapTitle($firstP)">
            <xsl:if test="true() or $debugBoolean">        
              <xsl:message> + [DEBUG] rsiwp:document: firstP is root map, calling makeMap...</xsl:message>
            </xsl:if>
            <xsl:call-template name="makeMap">
              <xsl:with-param name="content" select="rsiwp:body/(rsiwp:p | rsiwp:table)" as="node()*"/>
              <xsl:with-param name="level" select="0" as="xs:integer"/>
              <xsl:with-param name="newMapUrl" select="$rootMapUrl" as="xs:string"/>
              <xsl:with-param name="topicrefType" select="'mapref'"/><!-- shouldn't be necessary, but it is -->
              <xsl:with-param name="mapUrl" select="relpath:newFile($outputDir, 'garbage.ditamap')" tunnel="yes" as="xs:string"/>
              <xsl:with-param name="simpleWpDoc" as="document-node()" tunnel="yes"
                select="$simpleWpDoc"
              />            
            </xsl:call-template>
          </xsl:when>
          <xsl:when test="local:isRootTopicTitle($firstP)">
            <xsl:if test="$debugBoolean or true()">        
              <xsl:message> + [DEBUG] rsiwp:document: firstP is root topic title, calling makeTopic...</xsl:message>
            </xsl:if>
            <xsl:call-template name="makeTopic">
              <xsl:with-param name="content" select="rsiwp:body/(rsiwp:p|rsiwp:table)" as="node()*"/>
              <xsl:with-param name="level" select="0" as="xs:integer"/>
              <xsl:with-param name="treePos" select="(0)" as="xs:integer+" tunnel="yes"/>
              <xsl:with-param name="simpleWpDoc" as="document-node()" tunnel="yes"
                select="$simpleWpDoc"
              />            
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <xsl:if test="$debugBoolean or true()">        
              <xsl:message> + [DEBUG] rsiwp:document: firstP is neither root topic nor root map</xsl:message>
            </xsl:if>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:document>
    </xsl:variable>
    <!-- Write out the base resultDocs data for debugging purposes -->
    <xsl:if test="false() or $debugBoolean">
      <xsl:variable
        name="tempDoc"
        select="relpath:newFile($outputDir, 'resultDocs.xml')"
        as="xs:string"/>
      <xsl:message> + [DEBUG] saving $resultDocs to 
<xsl:sequence select="$tempDoc"/>        
      </xsl:message>
      <xsl:result-document href="{$tempDoc}">
        <xsl:sequence select="$resultDocs"/>
      </xsl:result-document>
    </xsl:if>
    <!-- Fixup xrefs in the result documents: -->
    <xsl:message> + [INFO] Fixing up xrefs in the result documents...</xsl:message>
    <xsl:variable name="resultDocsFixedUp" as="node()*">
      <xsl:apply-templates select="$resultDocs" mode="resultdocs-xref-fixup">
        <xsl:with-param name="simpleWpDoc" as="document-node()" tunnel="yes"
          select="$simpleWpDoc"
        />                  
      </xsl:apply-templates>
    </xsl:variable>
    <!-- Write out the fixed-up resultDocs data for debugging purposes -->
    <xsl:if test="false() or $debugBoolean">
      <xsl:variable
        name="tempDoc"
        select="relpath:newFile($outputDir, 'resultDocsFixedUp.xml')"
        as="xs:string"/>
      <xsl:message> + [DEBUG] saving $resultDocsFixedUp to 
        <xsl:sequence select="$tempDoc"/>        
      </xsl:message>
      <xsl:result-document href="{$tempDoc}">
        <xsl:sequence select="$resultDocsFixedUp"/>
      </xsl:result-document>
    </xsl:if>
    <!-- Generate the result documents: -->
    <xsl:message> + [INFO] Writing result documents...</xsl:message>
    <xsl:apply-templates select="$resultDocsFixedUp" mode="generate-result-docs">
      <xsl:with-param name="simpleWpDoc" as="document-node()" tunnel="yes"
        select="$simpleWpDoc"
      />                  
    </xsl:apply-templates>
    <xsl:message> + [INFO] simple2dita: Done processing simpleML document.</xsl:message>
    
  </xsl:template>
  
  <xsl:template mode="generate-result-docs" match="rsiwp:result-document" priority="10">
    <xsl:message> + [INFO] Generating result document "<xsl:sequence select="string(@href)"/>..."</xsl:message>
    <xsl:result-document href="{@href}" 
      doctype-public="{@doctype-public}"
      doctype-system="{@doctype-system}">
      <xsl:apply-templates select="./*" mode="generate-result-docs"/>
    </xsl:result-document>
  </xsl:template>
  
  <xsl:template mode="generate-result-docs" match="*" priority="5">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*,node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template mode="generate-result-docs" match="@*|node()">
    <xsl:copy/>
  </xsl:template>
  
  <xsl:template match="rsiwp:p[string(@structureType) = 'skip']" priority="10"/>
  
  <xsl:template match="rsiwp:p" name="transformPara">
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] rsiwp:p (transformPara): text=<xsl:sequence select="substring(., 1, 40)"/></xsl:message>
    </xsl:if>
    <xsl:variable name="tagName" as="xs:string"
      select="
      if (@tagName) 
      then string(@tagName)
      else 'p'
      "
    />
    <xsl:if test="not(./@tagName)">
      <xsl:message> + [WARNING] No style to tag mapping for paragraph style "<xsl:sequence select="string(@style)"/>"</xsl:message>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="count(./*) = 0 and normalize-space(.) = ''">
        <xsl:if test="$debugBoolean">
          <xsl:message> + [DEBUG] Skipping apparently-empty paragraph: <xsl:sequence select="local:reportPara(.)"/></xsl:message>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="idGenerator" as="xs:string">
          <xsl:choose>
            <xsl:when test="string(@idGenerator) = ''">
              <xsl:sequence select="''"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="string(@idGenerator)"/>
            </xsl:otherwise>
          </xsl:choose>
          
        </xsl:variable>
        <xsl:element name="{$tagName}">  
          <xsl:call-template name="generateXtrcAtt"/>
          <xsl:if test="$includeWordBackPointersBoolean">
            <xsl:attribute name="xtrf" select="ancestor::rsiwp:document[1]/@sourceDoc"/>
          </xsl:if>
          <xsl:apply-templates select="rsiwp:bookmarkStart" mode="generate-para-ids">
            <xsl:with-param name="tagName" select="$tagName"/>
          </xsl:apply-templates>
          <xsl:sequence select="./@outputclass"/>
          <xsl:if test="./@dataName">
            <xsl:attribute name="name" select="./@dataName"/>
          </xsl:if>
          <xsl:apply-templates select="." mode="generate-id">
            <xsl:with-param name="idGenerator" select="$idGenerator" as="xs:string"/>
            <xsl:with-param name="tagName" select="$tagName" as="xs:string"/>
          </xsl:apply-templates>
          <xsl:call-template name="transformParaContent"/>    
        </xsl:element>
      </xsl:otherwise>
    </xsl:choose>    
  </xsl:template>
  
  <xsl:template mode="generate-id" match="*">
    <xsl:param name="idGenerator" select="''"/>
    <xsl:choose>
      <xsl:when test="$idGenerator = ''">
        <!-- Don't generate an ID -->
      </xsl:when>
      <xsl:otherwise>
        <xsl:attribute name="id" select="generate-id(.)"/>
        <!-- This will be removed during ID fixup pass -->
        <xsl:attribute name="idGenerator" select="$idGenerator"/>
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:template>
  
  <xsl:template name="transformParaContent">
    <xsl:variable name="isTitlePara" as="xs:boolean"
      select="local:isTopicTitle(.)"
    />
    <!-- Transforms the content of a paragraph, where the containing
         element is generated by the caller. -->
    <xsl:choose>
      <xsl:when test="string(@useContent) = 'elementsOnly'">
        <xsl:apply-templates mode="p-content" select="*">
          <xsl:with-param name="inTitleContext" as="xs:boolean" tunnel="yes"
            select="$isTitlePara"
          />
        </xsl:apply-templates>
      </xsl:when>
      <xsl:when test="string(@putValueIn) = 'valueAtt'">
        <xsl:attribute name="value" select="string(.)"/>
        <xsl:if test="@dataName">
          <xsl:attribute name="name" select="string(@dataName)"/>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="p-content">
          <xsl:with-param name="inTitleContext" as="xs:boolean" tunnel="yes"
            select="$isTitlePara"
          />          
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:template>
  
  <!-- Much of the code used for table transformation comes from the DITA Open Toolkit's h2d plugin -->
  <xsl:template match="rsiwp:table">
    <xsl:variable name="cols-in-first-row">
      <xsl:choose>
        <xsl:when test="rsiwp:tbody/rsiwp:tr">
          <xsl:apply-templates select="(rsiwp:tbody[1]/rsiwp:tr[1]/rsiwp:td[1]|rsiwp:tbody[1]/rsiwp:tr[1]/rsiwp:th[1])[1]"
            mode="count-cols"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="(rsiwp:tr[1]/rsiwp:td[1]|rsiwp:tr[1]/rsiwp:th[1])[1]" mode="count-cols"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="width">
      <xsl:if test="@width">
        <xsl:value-of select="substring-before(@width,'%')"/>
      </xsl:if>
    </xsl:variable>
    <!--    <xsl:message> + [DEBUG] rsiwp:table: Starting...</xsl:message>-->
    <xsl:variable name="tagName" as="xs:string"
      select="
      if (@tagName) 
      then string(@tagName)
      else 'table'
      "
    />
    <xsl:element name="{$tagName}">  
      <xsl:call-template name="generateXtrcAtt"/>
      <xsl:if test="@align">
        <xsl:attribute name="align">
          <xsl:value-of select="@align"/>
        </xsl:attribute>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="number($width) &lt; 100">
          <xsl:attribute name="pgwide">0</xsl:attribute>
        </xsl:when>
        <xsl:when test="string-length($width)">
          <xsl:attribute name="pgwide">1</xsl:attribute>
        </xsl:when>
      </xsl:choose>
      
      <tgroup>
        <!-- add colspan data here -->
        <xsl:attribute name="cols">
          <xsl:value-of select="$cols-in-first-row"/>
        </xsl:attribute>
        <xsl:call-template name="create-colspec">
          <xsl:with-param name="total-cols">
            <xsl:value-of select="$cols-in-first-row"/>
          </xsl:with-param>
        </xsl:call-template>
        <xsl:choose>
          <xsl:when test="rsiwp:thead">
            <thead>
              <xsl:apply-templates select="rsiwp:thead/rsiwp:tr"/> <!-- FIXME: will this select anything? -->
            </thead>
          </xsl:when>
          <xsl:when test="rsiwp:tr[rsiwp:th and not(rsiwp:td)]"> <!-- FIXME: Will this ever select anything? I don't think we make rsiwp:th in wordml2simple -->
            <thead>
              <xsl:apply-templates select="rsiwp:tr[rsiwp:th and not(rsiwp:td)]"/>
            </thead>
          </xsl:when>
        </xsl:choose>
        <tbody>
          <xsl:choose>
            <xsl:when test="rsiwp:tbody/rsiwp:tr[rsiwp:td]|rsiwp:tr[rsiwp:td]">
              <xsl:apply-templates select="rsiwp:tbody/rsiwp:tr[rsiwp:td]|rsiwp:tr[rsiwp:td]"/>         
            </xsl:when>
            <xsl:otherwise>
              <row>
                <entry>Generated row for table with only header rows. DITA requires a body which requires a row.</entry>
              </row>
            </xsl:otherwise>
          </xsl:choose>
        </tbody>
      </tgroup>
    </xsl:element>
  </xsl:template>
  
    <xsl:template match="rsiwp:td|rsiwp:th">
        <entry>
            <xsl:if test="@rowspan">
                <xsl:attribute name="morerows">
                    <xsl:value-of select="number(@rowspan)-1"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@colspan">
                <!-- Allow entries to span columns -->
                <xsl:variable name="current-cell">
                    <xsl:call-template name="current-cell-position"/>
                </xsl:variable>
                <xsl:attribute name="namest">col<xsl:value-of select="$current-cell"/></xsl:attribute>
                <xsl:attribute name="nameend">col<xsl:value-of select="$current-cell + number(@colspan) - 1"
                /></xsl:attribute>
            </xsl:if>
            <xsl:choose>
                <xsl:when test="@align">
                    <xsl:attribute name="align">
                        <xsl:value-of select="@align"/>
                    </xsl:attribute>
                </xsl:when>
                <xsl:when test="../@align">
                    <xsl:attribute name="align">
                        <xsl:value-of select="../@align"/>
                    </xsl:attribute>
                </xsl:when>
            </xsl:choose>
            <xsl:call-template name="handleBodyParas">
                <xsl:with-param name="bodyParas" select="*"/>
            </xsl:call-template>
            <!-- Original for reference: 
      <xsl:choose>
        <xsl:when test="table">
          <p>
            <xsl:apply-templates select="*|text()|comment()"/>
          </p>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="*|text()|comment()"/>
        </xsl:otherwise>
      </xsl:choose> -->
        </entry>
    </xsl:template>
    
    
    <xsl:template match="rsiwp:tr|rsiwp:thead">
        <row>
            <xsl:if test="@valign">
                <xsl:attribute name="valign">
                    <xsl:value-of select="@valign"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:apply-templates/>
        </row>
    </xsl:template>
    
    <xsl:template match="rsiwp:td|rsiwp:th" mode="count-cols">
        <xsl:param name="current-count">1</xsl:param>
        <xsl:variable name="current-span">
            <xsl:choose>
                <xsl:when test="@colspan">
                    <xsl:value-of select="@colspan"/>
                </xsl:when>
                <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="following-sibling::rsiwp:th or following-sibling::rsiwp:td">
                <xsl:apply-templates select="(following-sibling::rsiwp:th|following-sibling::rsiwp:td)[1]"
                    mode="count-cols">
                    <xsl:with-param name="current-count">
                        <xsl:value-of select="number($current-span) + number($current-count)"/>
                    </xsl:with-param>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="@colspan">
                <xsl:value-of select="number($current-span) + number($current-count) - 1"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$current-count"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template name="create-colspec">
        <xsl:param name="total-cols">0</xsl:param>
        <xsl:param name="on-column">1</xsl:param>
        <xsl:if test="$on-column &lt;= $total-cols">
            <colspec>
                <xsl:attribute name="colname">col<xsl:value-of select="$on-column"/></xsl:attribute>
                <xsl:if test="@align">
                    <xsl:attribute name="align">
                        <xsl:value-of select="@align"/>
                    </xsl:attribute>
                </xsl:if>
            </colspec>
            <xsl:call-template name="create-colspec">
                <xsl:with-param name="total-cols">
                    <xsl:value-of select="$total-cols"/>
                </xsl:with-param>
                <xsl:with-param name="on-column">
                    <xsl:value-of select="$on-column + 1"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    
    
    <!-- Determine which column the current entry sits in. Count the current entry,
     plus every entry before it; take spanned rows and columns into account.
     If any entries in this table span rows, we must examine the entire table to
     be sure of the current column. Use mode="find-matrix-column".
     Otherwise, we just need to examine the current row. Use mode="count-cells". -->
    <xsl:template name="current-cell-position">
        <xsl:choose>
            <xsl:when test="parent::rsiwp:tr/parent::rsiwp:thead">
                <xsl:apply-templates select="(ancestor::rsiwp:table[1]/rsiwp:thead/rsiwp:tr/*[1])[1]"
                    mode="find-matrix-column">
                    <xsl:with-param name="stop-id">
                        <xsl:value-of select="generate-id(.)"/>
                    </xsl:with-param>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="ancestor::rsiwp:table[1]//*[@rowspan][1]">
                <xsl:apply-templates
                    select="(ancestor::rsiwp:table[1]/rsiwp:tbody/rsiwp:tr/*[1]|ancestor::rsiwp:table[1]/rsiwp:tr/*[1])[1]"
                    mode="find-matrix-column">
                    <xsl:with-param name="stop-id">
                        <xsl:value-of select="generate-id(.)"/>
                    </xsl:with-param>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="not(preceding-sibling::rsiwp:td|preceding-sibling::rsiwp:th)">1</xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="(preceding-sibling::rsiwp:th|preceding-sibling::rsiwp:td)[last()]"
                    mode="count-cells"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <!-- Count the number of cells in the current row. Move backwards from the test cell. Add one
     for each entry, plus the number of spanned columns. -->
    <xsl:template match="*" mode="count-cells">
        <xsl:param name="current-count">1</xsl:param>
        <xsl:variable name="new-count">
            <xsl:choose>
                <xsl:when test="@colspan">
                    <xsl:value-of select="$current-count + number(@colspan)"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$current-count + 1"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="not(preceding-sibling::rsiwp:td|preceding-sibling::rsiwp:th)">
                <xsl:value-of select="$new-count"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="(preceding-sibling::rsiwp:th|preceding-sibling::rsiwp:td)[last()]"
                    mode="count-cells">
                    <xsl:with-param name="current-count">
                        <xsl:value-of select="$new-count"/>
                    </xsl:with-param>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <!-- Set up a pseudo-matrix to find the column of the current entry. Start with the first entry
     in the first row. Progress to the end of the row, then start the next row; go until we find
     the test cell (with id=$stop-id).
     If an entry spans rows, add the cells that will be covered to $matrix.
     If we get to an entry and its position is already filled in $matrix, then the entry is pushed
     to the side. Add one to the column count and re-try the entry. -->
    <xsl:template match="*" mode="find-matrix-column">
        <xsl:param name="stop-id"/>
        <xsl:param name="matrix"/>
        <xsl:param name="row-count">1</xsl:param>
        <xsl:param name="col-count">1</xsl:param>
        <!-- $current-position has the format [1:3] for row 1, col 3. Use to test if this cell is covered. -->
        <xsl:variable name="current-position">[<xsl:value-of select="$row-count"/>:<xsl:value-of
            select="$col-count"/>]</xsl:variable>
        
        <xsl:choose>
            <!-- If the current value is already covered, increment the column number and try again. -->
            <xsl:when test="contains($matrix,$current-position)">
                <xsl:apply-templates select="." mode="find-matrix-column">
                    <xsl:with-param name="stop-id">
                        <xsl:value-of select="$stop-id"/>
                    </xsl:with-param>
                    <xsl:with-param name="matrix">
                        <xsl:value-of select="$matrix"/>
                    </xsl:with-param>
                    <xsl:with-param name="row-count">
                        <xsl:value-of select="$row-count"/>
                    </xsl:with-param>
                    <xsl:with-param name="col-count">
                        <xsl:value-of select="$col-count + 1"/>
                    </xsl:with-param>
                </xsl:apply-templates>
            </xsl:when>
            <!-- If this is the cell we are testing, return the current column number. -->
            <xsl:when test="generate-id(.)=$stop-id">
                <xsl:value-of select="$col-count"/>
            </xsl:when>
            <xsl:otherwise>
                <!-- Figure out what the next column value will be. -->
                <xsl:variable name="next-col-count">
                    <xsl:choose>
                        <xsl:when test="not(following-sibling::*)">1</xsl:when>
                        <xsl:when test="@colspan">
                            <xsl:value-of select="$col-count + number(@colspan) - 1"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$col-count + 1"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <!-- Determine any values that need to be added to the matrix, if this entry spans rows. -->
                <xsl:variable name="new-matrix-values">
                    <xsl:if test="@rowspan">
                        <xsl:call-template name="add-to-matrix">
                            <xsl:with-param name="start-row">
                                <xsl:value-of select="number($row-count)"/>
                            </xsl:with-param>
                            <xsl:with-param name="end-row">
                                <xsl:value-of select="number($row-count) + number(@rowspan) - 1"/>
                            </xsl:with-param>
                            <xsl:with-param name="start-col">
                                <xsl:value-of select="number($col-count)"/>
                            </xsl:with-param>
                            <xsl:with-param name="end-col">
                                <xsl:choose>
                                    <xsl:when test="@colspan">
                                        <xsl:value-of select="number($col-count) + number(@colspan) - 1"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="number($col-count)"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:if>
                </xsl:variable>
                <xsl:choose>
                    <!-- If there are more entries in this row, move to the next one. -->
                    <xsl:when test="following-sibling::*">
                        <xsl:apply-templates select="following-sibling::*[1]" mode="find-matrix-column">
                            <xsl:with-param name="stop-id">
                                <xsl:value-of select="$stop-id"/>
                            </xsl:with-param>
                            <xsl:with-param name="matrix">
                                <xsl:value-of select="$matrix"/>
                                <xsl:value-of select="$new-matrix-values"/>
                            </xsl:with-param>
                            <xsl:with-param name="row-count">
                                <xsl:value-of select="$row-count"/>
                            </xsl:with-param>
                            <xsl:with-param name="col-count">
                                <xsl:value-of select="$next-col-count"/>
                            </xsl:with-param>
                        </xsl:apply-templates>
                    </xsl:when>
                    <!-- Otherwise, move to the first entry in the next row. -->
                    <xsl:otherwise>
                        <xsl:apply-templates select="../following-sibling::rsiwp:tr[1]/*[1]" mode="find-matrix-column">
                            <xsl:with-param name="stop-id">
                                <xsl:value-of select="$stop-id"/>
                            </xsl:with-param>
                            <xsl:with-param name="matrix">
                                <xsl:value-of select="$matrix"/>
                                <xsl:value-of select="$new-matrix-values"/>
                            </xsl:with-param>
                            <xsl:with-param name="row-count">
                                <xsl:value-of select="$row-count + 1"/>
                            </xsl:with-param>
                            <xsl:with-param name="col-count">
                                <xsl:value-of select="1"/>
                            </xsl:with-param>
                        </xsl:apply-templates>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <!-- This template returns values that must be added to the table matrix. Every cell in the box determined
     by start-row, end-row, start-col, and end-col will be added. First add every value from the first
     column. When past $end-row, move to the next column. When past $end-col, every value is added. -->
    <xsl:template name="add-to-matrix">
        <xsl:param name="start-row"/>
        <xsl:param name="end-row"/>
        <xsl:param name="current-row">
            <xsl:value-of select="$start-row"/>
        </xsl:param>
        <xsl:param name="start-col"/>
        <xsl:param name="end-col"/>
        <xsl:param name="current-col">
            <xsl:value-of select="$start-col"/>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="$current-col > $end-col"/>
            <!-- Out of the box; every value has been added -->
            <xsl:when test="$current-row > $end-row">
                <!-- Finished with this column; move to next -->
                <xsl:call-template name="add-to-matrix">
                    <xsl:with-param name="start-row">
                        <xsl:value-of select="$start-row"/>
                    </xsl:with-param>
                    <xsl:with-param name="end-row">
                        <xsl:value-of select="$end-row"/>
                    </xsl:with-param>
                    <xsl:with-param name="current-row">
                        <xsl:value-of select="$start-row"/>
                    </xsl:with-param>
                    <xsl:with-param name="start-col">
                        <xsl:value-of select="$start-col"/>
                    </xsl:with-param>
                    <xsl:with-param name="end-col">
                        <xsl:value-of select="$end-col"/>
                    </xsl:with-param>
                    <xsl:with-param name="current-col">
                        <xsl:value-of select="$current-col + 1"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <!-- Output the value for the current entry -->
                <xsl:text>[</xsl:text>
                <xsl:value-of select="$current-row"/>:<xsl:value-of select="$current-col"/>
                <xsl:text>]</xsl:text>
                <!-- Move to the next row, in the same column. -->
                <xsl:call-template name="add-to-matrix">
                    <xsl:with-param name="start-row"><xsl:value-of select="$start-row"/></xsl:with-param>
                    <xsl:with-param name="end-row"><xsl:value-of select="$end-row"/></xsl:with-param>
                    <xsl:with-param name="current-row"><xsl:value-of select="$current-row + 1"
                    /></xsl:with-param>
                    <xsl:with-param name="start-col"><xsl:value-of select="$start-col"/></xsl:with-param>
                    <xsl:with-param name="end-col"><xsl:value-of select="$end-col"/></xsl:with-param>
                    <xsl:with-param name="current-col"><xsl:value-of select="$current-col"/></xsl:with-param>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
  
  <xsl:template match="rsiwp:run" mode="p-content">
    <xsl:variable name="tagName" as="xs:string"
      select="
      if (@tagName) 
      then string(@tagName)
      else 'ph'
      "
    />
    <xsl:if test="not(./@tagName)">
      <xsl:message> + [WARNING] No style to tag mapping for character style "<xsl:sequence select="string(@style)"/>"</xsl:message>
    </xsl:if>
    <xsl:element name="{$tagName}">
      <xsl:call-template name="generateXtrcAtt"/>
      <xsl:if test="@outputclass">
        <xsl:attribute name="outputclass" select="string(@outputclass)"/>
      </xsl:if>
      <xsl:apply-templates mode="#current"/>
    </xsl:element>
  </xsl:template>
  
  <xsl:template match="text()" mode="p-content">
    <xsl:copy/>
  </xsl:template>
  
  <xsl:template match="rsiwp:symbol" mode="p-content">
    <ph outputclass="symbol"
      ><data name="font" value="{@font}"
      /><xsl:apply-templates mode="#current"
      /></ph>
  </xsl:template>
  
  
  
  <xsl:template name="makeMap">
    <xsl:param name="content" as="element()+"/>
    <xsl:param name="level"  as="xs:integer"/><!-- Level of this topic -->
    <xsl:param name="treePos" as="xs:integer*" tunnel="yes"/><!-- Sequence of integers representing tree position of parent. --> 
    <xsl:param name="topicrefType" select="$content[1]/@topicrefType" as="xs:string"/>
    <xsl:param name="mapUrl" as="xs:string" tunnel="yes"/>
    
    <xsl:param name="newMapUrl" as="xs:string" 
      select="local:getResultUrlForMap($content[1], $topicrefType, $treePos, $mapUrl)"/>

    <xsl:variable name="firstP" select="$content[1]"/>
    
    <xsl:if test="false() or $debugBoolean">
      <xsl:message> + [DEBUG] makeMap: firstP=<xsl:value-of select="$firstP"/></xsl:message>
      <xsl:message> + [DEBUG] makeMap: treePos=<xsl:value-of select="$treePos"/></xsl:message>
    </xsl:if>
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] makeMap: newMapUrl=<xsl:sequence select="$newMapUrl"/></xsl:message>
    </xsl:if>
    
    <xsl:variable name="nextLevel" select="$level + 1" as="xs:integer"/>
    
    <xsl:variable name="formatName" select="$firstP/@format" as="xs:string?"/>
    <xsl:if test="not($formatName)">
      <xsl:message terminate="yes"> + [ERROR] makeMap: No format= attribute for paragraph style <xsl:sequence select="string($firstP/@styleId)"/>, which is mapped to structure type "map".</xsl:message>
    </xsl:if>
    
    <xsl:variable name="format" select="key('formats', $formatName, $styleMapDoc)[1]" as="element()?"/>
    <xsl:if test="not($format)">
      <xsl:message terminate="yes"> + [ERROR] makeMap: Failed to find &lt;output&gt; element for @format value "<xsl:sequence select="$formatName"/>" specified for style "<xsl:sequence select="string($firstP/@styleName)"/>" <xsl:sequence select="concat(' [', string($firstP/@styleId), ']')"/>. Check your style-to-tag mapping.</xsl:message>
    </xsl:if>
    
    <xsl:variable name="schemaAtts" as="attribute()*">
      <xsl:if test="$format/@noNamespaceSchemaLocation">
        <xsl:attribute name="xsi:noNamespaceSchemaLocation"
          select="string($format/@noNamespaceSchemaLocation)"
        />
      </xsl:if>
      <xsl:if test="$format/@schemaLocation != ''">
        <xsl:attribute name="xsi:schemaLocation"
          select="string($format/@schemaLocation)"
        />
      </xsl:if>      
    </xsl:variable>
    
    <xsl:variable name="prologType" as="xs:string"
      select="
      if ($firstP/@prologType and $firstP/@prologType != '')
      then $firstP/@prologType
      else 'topicmeta'
      "
    />
    
    <xsl:variable name="resultUrl" as="xs:string"
      select="relpath:newFile(relpath:getParent($mapUrl), $newMapUrl)"
    />
    
    <xsl:message> + [INFO] makeMap: Creating new map document "<xsl:sequence select="$resultUrl"/>"...</xsl:message>
    
    
    <rsiwp:result-document href="{$resultUrl}"
      doctype-public="{$format/@doctype-public}"
      doctype-system="{$format/@doctype-system}"
      indent="yes"
      >
      <xsl:element name="{$firstP/@mapType}">
        <xsl:sequence select="$schemaAtts"/>
        <xsl:call-template name="generateXtrcAtt"/>  
        <xsl:attribute name="xml:lang" select="$language"/>
        <xsl:attribute name="isMap" select="'true'"/>
        
        <!-- The first paragraph can simply trigger a (possibly) untitled map, or
          it can also be the map title. If it's the map title, generate it.
          First paragraph can also generate a root topicref and/or a topicref
          to a topic in addition to the map.
        -->
        <xsl:if test="local:isMapTitle($firstP)">
          <xsl:choose>
            <xsl:when test="$firstP/@containerType">              
              <!-- First N paras should be of the same container type. Process them
                   as a unit.
                -->
              <xsl:element name="{$firstP/@containerType}">
                <xsl:apply-templates select="local:getContainerTypeSiblings($firstP)">
                  <xsl:with-param name="mapUrl" select="$resultUrl" as="xs:string" tunnel="yes"/>
                </xsl:apply-templates>                  
              </xsl:element>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates select="$firstP">
                <xsl:with-param name="mapUrl" select="$resultUrl" as="xs:string" tunnel="yes"/>
              </xsl:apply-templates>              
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
        <xsl:if test="$content[string(@topicZone) = 'topicmeta' and string(@containingTopic) = 'root']">
          <xsl:variable name="prologParas" select="$content[string(@topicZone) = 'topicmeta' and string(@containingTopic) = 'root']" as="node()*"/>
          <!-- Now process any map-level topic metadata paragraphs. -->
          <xsl:element name="{$prologType}">
            <xsl:call-template name="generateXtrcAtt"/>
            <xsl:call-template name="handleTopicProlog">
              <xsl:with-param name="content" select="$prologParas"/>
            </xsl:call-template>
          </xsl:element>
        </xsl:if>
        
        <xsl:if test="false() or $debugBoolean">        
          <xsl:message> + [DEBUG] </xsl:message>
          <xsl:message> + [DEBUG] +++++++++++++</xsl:message>
          <xsl:message> + [DEBUG] </xsl:message>
          <xsl:message> + [DEBUG] makeMap: calling generateTopicrefs...</xsl:message>
        </xsl:if>
        <xsl:message> + [DEBUG] makeMap: $nextLevel="<xsl:sequence select="$nextLevel"/>"</xsl:message>
        <xsl:call-template name="generateTopicrefs">
          <xsl:with-param name="content" 
            select="
            
            (if (string($firstP/@secondStructureType) = 'topicTitle')
              then $content
              else $content[position() > 1])[(string(@structureType) = 'topicTitle' or 
            string(@structureType) = 'map' or 
            string(@structureType) = 'mapTitle' or
            string(@structureType) = 'topicHead' or
            string(@structureType) = 'topicGroup')]" as="node()*"/>
          <xsl:with-param name="level" 
            select="if ((string($firstP/@secondStructureType) = 'topicTitle')) 
               then $level else $nextLevel" 
               as="xs:integer"
          />
          <xsl:with-param name="mapUrl" select="$resultUrl" as="xs:string" tunnel="yes"/>
        </xsl:call-template>
        <xsl:if test="false() or $debugBoolean">        
          <xsl:message> + [DEBUG] </xsl:message>
          <xsl:message> + [DEBUG] +++++++++++++</xsl:message>
          <xsl:message> + [DEBUG] </xsl:message>
          <xsl:message> + [DEBUG] makeMap: Calling generateTopics...
            </xsl:message>
        </xsl:if>
        <xsl:call-template name="generateTopics">
          <xsl:with-param name="content" 
            select="
            if (string($firstP/@secondStructureType) = 'topicTitle') 
               then $content
               else $content[position() > 1]" as="node()*"/>
          <xsl:with-param name="level" 
            select="if ((string($firstP/@secondStructureType) = 'topicTitle')) 
            then $level else $nextLevel" 
            as="xs:integer"/>
          <xsl:with-param name="mapUrl" select="$resultUrl" as="xs:string" tunnel="yes"/>
        </xsl:call-template>        
      </xsl:element>
    </rsiwp:result-document>
    <xsl:if test="false() or $debugBoolean">        
      <xsl:message> + [DEBUG] makeMap: Done.</xsl:message>
    </xsl:if>
  </xsl:template>
  
  <xsl:template name="handleTopicProlog">
    <xsl:param name="content" as="node()*"/>
    
    <xsl:call-template name="handleBodyParas">
      <xsl:with-param name="bodyParas" select="$content"/>
    </xsl:call-template>
    
  </xsl:template>
  
  <!-- Generate topicsrefs and topicheads.
  -->
  <xsl:template name="generateTopicrefs">
    <xsl:param name="content" as="node()*"/>
    <xsl:param name="level" as="xs:integer"/>
    <xsl:param name="treePos" as="xs:integer*" tunnel="yes"/>
    <xsl:param name="mapUrl" as="xs:string" tunnel="yes"/>
    
    <xsl:message> + [DEBUG] generateTopicrefs: Starting, level=<xsl:sequence select="$level"/></xsl:message>
   <xsl:if test="$debugBoolean">
     <xsl:message> + [DEBUG] generateTopicrefs: Starting, content:
<xsl:sequence select="local:reportParas($content)"/>
     </xsl:message>
   </xsl:if>   
    <xsl:variable name="firstP" select="$content[1]" as="element()"/>
    
    <xsl:variable name="generatedTopicrefs" as="node()*">
      <xsl:for-each-group select="$content"
        group-starting-with="*[(string(@structureType) = 'topicTitle' or 
        string(@structureType) = 'map' or 
        string(@structureType) = 'mapTitle' or
        string(@structureType) = 'topicHead' or
        string(@structureType) = 'topicGroup')  and
        string(@level) = string($level)]"
        >
        <xsl:variable name="groupFirstP" select="current-group()[1]" as="element()"/>

        <xsl:choose>
          <xsl:when test="$groupFirstP/@topicrefType != ''">
            <xsl:variable name="topicName" as="xs:string">
              <xsl:apply-templates mode="topic-name" select="($groupFirstP)">
                <xsl:with-param name="treePos" select="($treePos, position())" as="xs:integer*"/>
              </xsl:apply-templates>
            </xsl:variable>
            
            <xsl:variable name="topicrefType" 
              select="if (string($groupFirstP/@topicrefType) != '')
              then string($groupFirstP/@topicrefType)
              else 'topicref'
              "
              as="xs:string"
            />
            
            <xsl:variable name="topicUrl"
              as="xs:string"
              select="local:getResultUrlForTopic($groupFirstP, 
              $topicrefType, 
              ($treePos, position()), 
              $mapUrl, 
              $topicName)"
            />
            <xsl:element name="{$groupFirstP/@topicrefType}">
              <xsl:call-template name="generateXtrcAtt"/>
              <!-- Indicate that this is a topicref so that we can distinguish
                   it from topic elements with the same word location. -->
              <xsl:attribute name="isTopicref" select="'true'"/>
              <xsl:call-template name="generateTopicrefAtts">
                <xsl:with-param name="topicUrl" select="$topicUrl"/>
              </xsl:call-template>            
              <xsl:if test="count(current-group()) > 1">
                <xsl:call-template name="generateTopicrefs">
                  <xsl:with-param name="content" select="current-group()[position() > 1]"/>
                  <xsl:with-param name="level" select="$level + 1"/>
                  <xsl:with-param name="treePos" select="($treePos, position())"  tunnel="yes"/>
                </xsl:call-template>    
              </xsl:if>
            </xsl:element>
          </xsl:when>
          <xsl:otherwise>
            <xsl:if test="count(current-group()) > 1">
              <xsl:call-template name="generateTopicrefs">
                <xsl:with-param name="content" select="current-group()[position() > 1]"/>
                <xsl:with-param name="level" select="$level + 1"/>
                <xsl:with-param name="treePos" select="($treePos, position())" tunnel="yes"/>
              </xsl:call-template>    
            </xsl:if>
          </xsl:otherwise>
        </xsl:choose>          
      </xsl:for-each-group>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$firstP[@rootTopicrefType != '']">
        <xsl:element name="{$firstP/@rootTopicrefType}">
          <xsl:call-template name="generateXtrcAtt"/>
          <xsl:attribute name="isTopicref" select="'true'"/>          
          <xsl:if test="string($firstP/@rootTopicrefType) = 'learningObject'">
            <!-- FIXME: This is a workaround until we implement the ability
              to specify collection-type for the root topicref type.
            -->
            <xsl:attribute name="collection-type" select="'sequence'"/>
          </xsl:if>
          <xsl:sequence select="$generatedTopicrefs"/>
        </xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$generatedTopicrefs"/>
      </xsl:otherwise>
    </xsl:choose>
    
    
  </xsl:template>
  
  <!-- Generate topicsrefs and topicheads.
  -->
  <xsl:template name="generateTopicrefs-orig">
    <xsl:param name="content" as="node()*"/>
    <xsl:param name="level" as="xs:integer"/>
    <xsl:param name="treePos" as="xs:integer*" tunnel="yes"/>
    <xsl:param name="mapUrl" as="xs:string" tunnel="yes"/>
    <xsl:variable name="firstP" select="$content[1]" as="element()"/>
    
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] *** generateTopicrefs: treePos=<xsl:sequence select="$treePos"/></xsl:message>
    </xsl:if>

    <xsl:variable name="topicName" as="xs:string">
      <xsl:apply-templates mode="topic-name" select="($firstP)">
        <xsl:with-param name="treePos" select="($treePos, 1)" as="xs:integer*" />
      </xsl:apply-templates>
    </xsl:variable>
    
    <xsl:variable name="topicrefType" 
      select="if (string(@topicrefType) != '')
      then string(@topicrefType)
      else 'topicref'
      "
      as="xs:string"
    />    
    
    <xsl:variable name="topicUrl"
      as="xs:string"
      select="local:getResultUrlForTopic($firstP, $topicrefType, ($treePos, 1), $mapUrl, $topicName)"
    />
    
    <xsl:choose>
      <xsl:when test="$firstP/@rootTopicrefType != ''">
        <xsl:if test="$debugBoolean">                  
          <xsl:message> + [DEBUG] generateTopicrefs(): First para specifies rootTopicrefType</xsl:message>
        </xsl:if>
        <xsl:element name="{$firstP/@rootTopicrefType}">
          <xsl:call-template name="generateXtrcAtt"/>
          <xsl:attribute name="isTopicref" select="'true'"/>          
          <xsl:if test="string($firstP/@rootTopicrefType) = 'learningObject'">
          <!-- FIXME: This is a workaround until we implement the ability
            to specify collection-type for the root topicref type.
          -->
          <xsl:attribute name="collection-type" select="'sequence'"/>
        </xsl:if>
          <xsl:choose>
            <xsl:when test="@topicrefType != ''">
              <xsl:element name="{@topicrefType}">
                <xsl:call-template name="generateXtrcAtt"/>
                <xsl:attribute name="isTopicref" select="'true'"/>                
                <xsl:call-template name="generateTopicrefAtts">
                  <xsl:with-param name="topicUrl" select="$topicUrl"/>
                </xsl:call-template>            
                <xsl:call-template name="generateSubordinateTopicrefs">
                  <xsl:with-param name="content" select="$content"/>
                  <xsl:with-param name="level" select="$level"/>
                </xsl:call-template>    
              </xsl:element>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="generateSubordinateTopicrefs">
                <xsl:with-param name="content" select="$content"/>
                <xsl:with-param name="level" select="$level"/>
              </xsl:call-template>    
            </xsl:otherwise>
          </xsl:choose>          
        </xsl:element>
      </xsl:when>
      <xsl:when test="$firstP/@topicrefType">
        <xsl:if test="$debugBoolean and true()">                  
          <xsl:message> + [DEBUG] generateTopicrefs(): First para specifies topicrefType but not rootTopicrefType</xsl:message>
        </xsl:if>
        <xsl:element name="{$firstP/@topicrefType}">
          <xsl:attribute name="isTopicref" select="'true'"/>          
          <xsl:call-template name="generateTopicrefAtts">
            <xsl:with-param name="topicUrl" select="$topicUrl"/>
          </xsl:call-template>            
          <xsl:call-template name="generateSubordinateTopicrefs">
            <xsl:with-param name="content" select="$content" as="node()*"/>
            <xsl:with-param name="level" select="$level + 1"/>
          </xsl:call-template>    
        </xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="$debugBoolean and true()">                  
          <xsl:message> + [DEBUG] generateTopicrefs(): First para does not specify topicrefType</xsl:message>
        </xsl:if>
        <xsl:call-template name="generateSubordinateTopicrefs">
          <xsl:with-param name="content" select="$content"/>
          <xsl:with-param name="level" select="$level"/>
        </xsl:call-template>    
      </xsl:otherwise>
    </xsl:choose>
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] generateTopicrefs: Done.</xsl:message>
    </xsl:if>
  </xsl:template>
  
  <xsl:template name="generateSubordinateTopicrefs">
    <xsl:param name="content" as="node()*"/>
    <xsl:param name="level" as="xs:integer"/>
    <xsl:param name="treePos" as="xs:integer*" tunnel="yes" select="()"/>
    <xsl:param name="mapUrl" as="xs:string" tunnel="yes"/>
    
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] generateSubordinateTopicrefs: level=<xsl:sequence select="$level"/>.</xsl:message>
    </xsl:if>
    <xsl:for-each-group select="$content[position() > 1]" 
      group-starting-with="*[(string(@structureType) = 'topicTitle' or 
      string(@structureType) = 'map' or 
      string(@structureType) = 'mapTitle' or
      string(@structureType) = 'topicHead' or
      string(@structureType) = 'topicGroup')  and
      string(@level) = string($level)]">
      <xsl:variable name="topicrefType" as="xs:string"
        select="if (@topicrefType) then @topicrefType else 'topicref'"
      />
      <xsl:choose>
        <xsl:when test="string(@structureType) = 'topicTitle' and string(@topicDoc) = 'yes'">
          <xsl:if test="$debugBoolean">        
            <xsl:message> + [DEBUG] generateTopicrefs: Got a doc-creating topic title. Level=<xsl:sequence select="string(@level)"/></xsl:message>
          </xsl:if>
          <xsl:variable name="topicName" as="xs:string">
            <xsl:apply-templates mode="topic-name" select="current-group()[1]">
              <xsl:with-param name="treePos" select="($treePos, position())" as="xs:integer+"/>
            </xsl:apply-templates>
          </xsl:variable>
          
          
          <xsl:variable name="topicUrl"
            as="xs:string"
            select="local:getResultUrlForTopic(current-group()[1], $topicrefType, ($treePos, position()), $mapUrl, $topicName)"
          />
          <xsl:element name="{$topicrefType}">
            <xsl:attribute name="isTopicref" select="'true'"/>            
            <xsl:call-template name="generateTopicrefAtts">
              <xsl:with-param name="topicUrl" select="$topicUrl"/>
            </xsl:call-template>            
            <xsl:if test="current-group()[position() > 1]">
              <xsl:call-template name="generateTopicrefs">
                <xsl:with-param name="content" select="current-group()[position() > 1]" as="node()*"/>
                <xsl:with-param name="level" select="$level + 1"  as="xs:integer"/>
              </xsl:call-template>
            </xsl:if>
          </xsl:element>          
        </xsl:when>
        <xsl:when test="string(@structureType) = 'topichead'">
          
          <xsl:if test="$debugBoolean">        
            <xsl:message> + [DEBUG] generateTopicrefs: Got a topic head. Level=<xsl:sequence select="string(@level)"/></xsl:message>
          </xsl:if>
          <xsl:variable name="topicheadType" select="if (@topicheadType) then string(@topicheadType) else 'topichead'"/>
          <xsl:variable name="topicmetaType" select="if (@topicmetaType) then string(@topicmetaType) else 'topicmeta'"/>
          <xsl:variable name="navtitleType" select="if (@navtitleType) then string(@navtitleType) else 'navtitle'"/>
          <xsl:element name="{$topicheadType}">
            <xsl:call-template name="generateXtrcAtt"/>
            <xsl:attribute name="isTopicref" select="'true'"/>            
            <xsl:element name="{$topicmetaType}">
              <xsl:call-template name="generateXtrcAtt"/>
              <xsl:apply-templates select="current-group()[1]"/>
            </xsl:element>
            <xsl:call-template name="generateTopicrefs">
              <xsl:with-param name="content" select="current-group()[position() > 1]" as="node()*"/>
              <xsl:with-param name="level" select="$level + 1" as="xs:integer"/>
              <xsl:with-param name="treePos" select="($treePos, position() - 2)" tunnel="yes"/>
            </xsl:call-template>
          </xsl:element>          
        </xsl:when>
        <xsl:when test="string(@structureType) = 'map' or string(@structureType) = 'mapTitle'">
          <xsl:if test="$debugBoolean">        
            <xsl:message> + [DEBUG] generateTopicrefs: Got a map-reference-generating map or map title. Level=<xsl:sequence select="string(@level)"/></xsl:message>
          </xsl:if>
          <xsl:variable name="mapRefType" as="xs:string"
          >
            <xsl:choose>
              <xsl:when test="@mapRefType != ''">
                <xsl:sequence select="string(@mapRefType)"/>
              </xsl:when>
              <xsl:when test="@rootTopicrefType != ''">
                <xsl:sequence select="string(@rootTopicrefType)"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$topicrefType"/>
              </xsl:otherwise>
            </xsl:choose>
            
          </xsl:variable>
          <xsl:variable name="newMapUrl" as="xs:string" 
            select="local:getResultUrlForMap(., $mapRefType, ($treePos, position() - 2), $mapUrl)">
          </xsl:variable>
          <xsl:element name="{$mapRefType}">
            <xsl:attribute name="format" select="'ditamap'"/>
            <xsl:attribute name="navtitle" select="."/>
            <xsl:attribute name="href" select="relpath:getRelativePath(relpath:getParent($mapUrl), $newMapUrl)"/>
            <xsl:call-template name="generateXtrcAtt"/>
            <xsl:attribute name="isTopicref" select="'true'"/>
            
            <xsl:for-each select="./*[string(@structureType) = 'topicTitle' and @level = $level]">
              <xsl:call-template name="generateTopicrefs">
                <xsl:with-param name="content" select="current-group()[position() > 1]" as="node()*"/>
                <xsl:with-param name="treePos" select="($treePos, $level, position())" as="xs:integer+" tunnel="yes"/>
                <xsl:with-param name="mapUrl" select="$newMapUrl" tunnel="yes"/>
              </xsl:call-template>
            </xsl:for-each>
            
            
          </xsl:element>          
        </xsl:when>
        <xsl:when test="current-group()[position() = 1]">
          <!-- Ignore this stuff since it should be map metadata or ignorable stuff -->
        </xsl:when>
        <xsl:otherwise>
          <xsl:message> + [WARNING] generateTopicrefs: Shouldn't be here, first para=<xsl:sequence select="current-group()[1]"/></xsl:message>
        </xsl:otherwise>
      </xsl:choose>          
    </xsl:for-each-group>
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] generateSubordinateTopicrefs: Done.</xsl:message>
    </xsl:if>
    
  </xsl:template>
  <xsl:template name="generateTopicrefAtts">
    <xsl:param name="topicUrl"/>
    <xsl:param name="mapUrl" tunnel="yes" as="xs:string"/>
    
    <xsl:variable name="topicRelUrl"
      select="relpath:getRelativePath(relpath:getParent($mapUrl), $topicUrl)"
    />
    
    <xsl:attribute name="href" select="$topicRelUrl"/>
    <xsl:if test="@chunk">
      <xsl:copy-of select="@chunk"/>
    </xsl:if>
    <xsl:if test="@collection-type">
      <xsl:copy-of select="@collection-type"/>
    </xsl:if>
    <xsl:if test="@processing-role">
      <xsl:copy-of select="@processing-role"/>
    </xsl:if>
    <xsl:call-template name="generateXtrcAtt"/>
      
  </xsl:template>
  
  
 
  <!-- Generates topics and submaps. Generation of topicrefs in maps is handled by separate
       mode and processing pass.
    -->
  <xsl:template name="generateTopics">
    <xsl:param name="content" as="node()*"/>
    <xsl:param name="level" as="xs:integer"/>
    <xsl:param name="treePos" as="xs:integer*" tunnel="yes" select="()"/>
    <xsl:if test="false() or $debugBoolean">        
      <xsl:message> + [DEBUG] *** generateTopics: Starting, level=<xsl:sequence select="$level"/>, treePos=<xsl:sequence select="$treePos"/></xsl:message>
    </xsl:if>
    
    <!-- First paragraph is a special case because a first para
         may generate both a map and a topicref.
      -->
    <xsl:variable name="firstP" select="$content[1]" as="element()*"/>
    <xsl:variable name="firstStructureType" as="xs:string*" select="$firstP/@structureType"/>
    <xsl:if test="not($firstStructureType = ('topicTitle', 'map', 'mapTitle'))">
      <xsl:message terminate="yes"> + [ERROR] First paragraph following the root-map-generating paragraph
 + [ERROR] is not a topic title, map, or map title paragraph. You cannot have content paragraphs
 + [ERROR] between the publication title and the first topic-generating paragraph.
 + [ERROR] Paragraph has structureType of "<xsl:sequence select="string($firstP/@structureType)"/>"
 + [ERROR] and a style of "<xsl:sequence select="string($firstP/@style)"/>".
      </xsl:message>
    </xsl:if>
    
    <xsl:for-each-group select="$content" 
      group-starting-with="*[(string(@structureType) = 'topicTitle' or string(@structureType) = 'map' or string(@structureType) = 'mapTitle') and
      string(@level) = string($level)]">
      <xsl:if test="false() or $debugBoolean">
        <xsl:message> + [DEBUG] generateTopics: In for-each-group:</xsl:message>
        <xsl:message> + [DEBUG]        group=<xsl:sequence select="current-group()"/></xsl:message>
        <xsl:message> + [DEBUG]        position()=<xsl:sequence select="position()"/></xsl:message>
        <xsl:message> + [DEBUG]    @structureType=<xsl:sequence select="string(@structureType)"/></xsl:message>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="string(@structureType) = 'topicTitle' and string(@secondStructureType) = 'mapTitle'">
          <xsl:call-template name="makeMap">
            <xsl:with-param name="content" select="current-group()" as="node()*"/>
            <xsl:with-param name="level" select="$level" as="xs:integer"/>
            <xsl:with-param name="treePos" select="($treePos, ( position() -2))" tunnel="yes"/>            
          </xsl:call-template>
          <xsl:call-template name="makeTopic">
            <xsl:with-param name="content" select="current-group()" as="node()*"/>
            <xsl:with-param name="level" select="$level" as="xs:integer"/>
            <xsl:with-param name="treePos" select="($treePos, position())" tunnel="yes"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="string(@structureType) = 'topicTitle'">
          <xsl:call-template name="makeTopic">
            <xsl:with-param name="content" select="current-group()" as="node()*"/>
            <xsl:with-param name="level" select="$level" as="xs:integer"/>
            <xsl:with-param name="treePos" select="($treePos, position())" tunnel="yes"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="string(@structureType) = 'map' or string(@structureType) = 'mapTitle'">
          <xsl:choose>
            <xsl:when test="count(. | $firstP) = 1">
              <xsl:choose>
                <xsl:when test="@topicrefType != ''">
                  <xsl:call-template name="makeTopic">
                    <xsl:with-param name="content" select="current-group()" as="node()*"/>
                    <xsl:with-param name="level" select="$level" as="xs:integer"/>
                    <xsl:with-param name="treePos" select="($treePos, position())" tunnel="yes"/>
                    <xsl:with-param name="topicrefType" select="string(@topicrefType)" as="xs:string"/>
                  </xsl:call-template>
                </xsl:when>
                <xsl:otherwise/><!-- Just a map generator, ignore the paragraph -->
              </xsl:choose>              
            </xsl:when>
            <xsl:otherwise><!-- Not the first para, handle normally -->
              <xsl:call-template name="makeMap">
                <xsl:with-param name="content" select="current-group()" as="node()*"/>
                <xsl:with-param name="level" select="$level" as="xs:integer"/>
                <xsl:with-param name="treePos" select="($treePos, position() -2)" tunnel="yes"/>
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>          
        </xsl:when>
        <xsl:when test="current-group()[position() = 1]">
          <!-- Ignore this stuff since it should be map metadata or ignorable stuff -->
        </xsl:when>
        <xsl:otherwise>
          <xsl:message> + [WARNING] generateTopics: Shouldn't be here, first para=<xsl:sequence select="current-group()[1]"/></xsl:message>
        </xsl:otherwise>
      </xsl:choose>          
    </xsl:for-each-group>
    
  </xsl:template>
  
  <xsl:template name="makeTopic">
    <xsl:param name="content" as="node()+"/>
    <xsl:param name="level" as="xs:integer"/><!-- Level of this topic -->
    <xsl:param name="treePos" as="xs:integer+" tunnel="yes"/><!-- Tree position of topic in map tree -->
    <xsl:param name="topicrefType" select="$content[1]/@topicrefType" as="xs:string?"/>
    <xsl:param name="mapUrl" as="xs:string?" tunnel="yes"/>
    
    
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] makeTopic: treePos=<xsl:sequence select="$treePos"/></xsl:message>
      <xsl:message> + [DEBUG] makeTopic: level=<xsl:sequence select="$level"/></xsl:message>
      <xsl:message> + [DEBUG] makeTopic: rootTopicUrl=<xsl:sequence select="$rootTopicUrl"/></xsl:message>
    </xsl:if>

    <xsl:variable name="firstP" select="$content[1]"/>
    
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] makeTopic: firstP=<xsl:sequence select="$firstP"/></xsl:message>
    </xsl:if>
    
    <xsl:variable name="topicFileName" select="substring-before($firstP,' ')"/>
    <xsl:variable name="makeDoc" 
      select="string($firstP/@topicDoc) = 'yes' or 
      (($level = 0) and $rootTopicUrl)" 
      as="xs:boolean"
    />

    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] makeTopic: makeDoc=<xsl:value-of select="$makeDoc"/></xsl:message>
    </xsl:if>

    <xsl:choose>
      <xsl:when test="$makeDoc">
        <xsl:variable name="topicName" as="xs:string">
          <xsl:apply-templates mode="topic-name" select="$firstP">
            <xsl:with-param name="treePos" select="$treePos" as="xs:integer+"/>
          </xsl:apply-templates>
        </xsl:variable>
        
        <xsl:choose>
          <xsl:when test="($level = 0) and $rootTopicUrl">
            <!-- As it should be -->
          </xsl:when>
          <xsl:when test="not(($level = 0) and $rootTopicUrl) and not($mapUrl)">
            <xsl:message terminate="yes"
> + [ERROR] Style "<xsl:sequence select="$firstP/@styleName"/>" has @topicDoc = 'yes' but there is no corresponding map URL. If the style is the root style and you are not generating a map, do not
specify @topicDoc="yes".</xsl:message>
          </xsl:when>
        </xsl:choose>
        
        <xsl:variable name="topicUrl"
           as="xs:string"
           select="
           if (($level = 0) and $rootTopicUrl)
              then $rootTopicUrl
              else local:getResultUrlForTopic($firstP, $topicrefType, $treePos, $mapUrl, $topicName)"
        />
        
        <xsl:variable name="resultUrl" as="xs:string"
            select="relpath:newFile($outputDir,$topicUrl)"
        />
        
        <xsl:message> + [INFO] Creating new topic document "<xsl:sequence select="$resultUrl"/>"...</xsl:message>
        
        <xsl:variable name="formatName" select="$firstP/@topicType" as="xs:string?"/>
        <xsl:if test="not($formatName)">
          <xsl:message terminate="yes"> + [ERROR] No topicType= attribute for paragraph style <xsl:sequence select="string($firstP/@styleId)"/>, when topicDoc="yes".</xsl:message>
        </xsl:if>
        
        <xsl:if test="$debugBoolean">
          <xsl:message> + [DEBUG] makeTopic: formatName="<xsl:sequence select="$formatName"/>"</xsl:message>
        </xsl:if>
        
        <xsl:variable name="format" select="key('formats', $formatName, $styleMapDoc)[1]" as="element()?"/>
        <xsl:if test="not($format)">
          <xsl:message terminate="yes"> + [ERROR] makeMap: Failed to find &lt;output&gt; element for @format value "<xsl:sequence select="$formatName"/>" specified for style "<xsl:sequence select="string($firstP/@styleName)"/>" <xsl:sequence select="concat(' [', string($firstP/@styleId), ']')"/>. Check your style-to-tag mapping.</xsl:message>
        </xsl:if>
        <xsl:if test="$debugBoolean">
          <xsl:message> + [DEBUG] makeTopic: format="<xsl:sequence select="$format"/>"</xsl:message>
        </xsl:if>
                
        <xsl:variable name="schemaAtts" as="attribute()*">
          <xsl:if test="$format/@noNamespaceSchemalocation">
            <xsl:attribute name="xsi:noNamespaceSchemaLocation"
              select="string($format/@noNamespaceSchemaLocation)"
            />
          </xsl:if>
          <xsl:if test="$format/@schemaLocation != ''">
            <xsl:attribute name="xsi:schemaLocation"
              select="string($format/@schemaLocation)"
            />
          </xsl:if>
        </xsl:variable>
        <xsl:if test="false() or $debugBoolean">
          <xsl:message> + [DEBUG] makeTopic: schemaAtts=<xsl:sequence select="$schemaAtts"/></xsl:message>
        </xsl:if>
        
        
        <xsl:variable name="resultDoc" as="node()*"> 
          <xsl:call-template name="constructTopic">
            <xsl:with-param name="content" select="$content"  as="node()*"/>
            <xsl:with-param name="level" select="$level" as="xs:integer"/>
            <xsl:with-param name="resultUrl" as="xs:string" tunnel="yes" select="$resultUrl"/>
            <xsl:with-param name="topicName" as="xs:string" tunnel="yes" select="$topicName"/>
            <xsl:with-param name="schemaAtts" as="attribute()*" select="$schemaAtts"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:if test="$debugBoolean">
          <xsl:message> + DEBUG: $format=<xsl:sequence select="$format"/></xsl:message>
        </xsl:if>
        <!-- Now do ID fixup on the result document: -->
        <xsl:message> + [INFO] Applying final-fixup mode to <xsl:sequence select="$resultUrl"/>...</xsl:message>
        <rsiwp:result-document href="{$resultUrl}"
            doctype-public="{$format/@doctype-public}"
            doctype-system="{$format/@doctype-system}"
            >
          <xsl:apply-templates select="$resultDoc" mode="final-fixup"/>
        </rsiwp:result-document>
        <xsl:message> + [INFO] final-fixup mode applied.</xsl:message>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="topicName" as="xs:string">
          <xsl:apply-templates mode="topic-name" select="$firstP">
            <xsl:with-param name="treePos" select="$treePos" as="xs:integer+"/>
          </xsl:apply-templates>
        </xsl:variable>
        <xsl:choose>
          <xsl:when test="$level = 0">
            <xsl:variable name="initialDitaContent" as="node()*">
              <xsl:call-template name="constructTopic">
                <xsl:with-param name="content" select="$content" as="node()*"/>
                <xsl:with-param name="level" select="$level" as="xs:integer"/>
                <xsl:with-param name="topicName" as="xs:string" tunnel="yes" select="$topicName"/>
              </xsl:call-template>              
            </xsl:variable>
            <xsl:message> + [INFO] Applying final-fixup mode to main result topic...</xsl:message>
            <xsl:apply-templates select="$initialDitaContent" mode="final-fixup"/>
            <xsl:message> + [INFO] final-fixup mode applied.</xsl:message>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="constructTopic">
              <xsl:with-param name="content" select="$content" as="node()*"/>
              <xsl:with-param name="level" select="$level" as="xs:integer"/>
              <xsl:with-param name="topicName" as="xs:string" tunnel="yes" select="$topicName"/>
            </xsl:call-template>            
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="final-fixup" match="*">
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] final-fixup: handling <xsl:sequence select="name(.)"/></xsl:message>
    </xsl:if>
    <xsl:copy>
      <xsl:apply-templates select="@*,node()" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template mode="final-fixup" match="@id" priority="2">
    <!-- Override this template to implement specific ID generators -->
    <xsl:variable name="idGenerator" select="string(../@idGenerator)" as="xs:string"/>
    <xsl:choose>
      <xsl:when test="$idGenerator = '' or $idGenerator = 'default'">
        <xsl:if test="$debugBoolean">
          <xsl:message> + [DEBUG] final-fixup/@ID: Using default ID generator, returning "<xsl:sequence select="string(.)"/>"</xsl:message>
        </xsl:if>
        <xsl:copy/><!-- Use the base generated ID value. -->
      </xsl:when>
      <xsl:otherwise>
        <xsl:message> - [WARNING] Unrecognized ID generator name "<xsl:sequence select="$idGenerator"/>"</xsl:message>
        <xsl:copy/><!-- Use the base generated ID value. -->
      </xsl:otherwise>
    </xsl:choose>    
  </xsl:template>
  
  <xsl:template mode="final-fixup" match="@idGenerator | @class">
    <!-- Suppress -->
  </xsl:template>
  
  <xsl:template mode="final-fixup" match="@*">
    <xsl:copy/>
  </xsl:template>
  
  <xsl:template mode="final-fixup" match="text() | processing-instruction()">
    <xsl:copy/>
  </xsl:template>
  
  <!-- Constructs the topic itself -->
  <xsl:template name="constructTopic">
    <xsl:param name="content" as="node()*"/>
    <xsl:param name="level" as="xs:integer"/>
    <xsl:param name="topicName" as="xs:string" tunnel="yes" select="generate-id(.)"/>
    <xsl:param name="treePos" as="xs:integer+" tunnel="yes"/><!-- Tree position of topic in map tree -->
    <xsl:param name="schemaAtts" as="attribute()*" select="()"/>
    
    <xsl:variable name="initialSectionType" as="xs:string" select="string(@initialSectionType)"/>
    <xsl:variable name="firstP" select="$content[1]"/>
    <xsl:variable name="nextLevel" select="$level + 1" as="xs:integer"/>
 
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] constructTopic: firstP=<xsl:sequence select="local:reportPara($firstP)"/></xsl:message>
    </xsl:if>
    
    <xsl:variable name="topicType" as="xs:string"
      select="local:getTopicType($firstP)"
    />
    
    <xsl:variable name="bodyType" as="xs:string"
      select="
      if ($firstP/@bodyType)
      then $firstP/@bodyType
      else 'body'
      "
    />
    
    <xsl:variable name="prologType" as="xs:string"
      select="
      if ($firstP/@prologType and $firstP/@prologType != '' and 
          not(@secondStructureType = 'topicTitle'))
      then $firstP/@prologType
      else 'prolog'
      "
    />
    
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] constructTopic: topicType="<xsl:value-of select="$topicType"/>"</xsl:message>
      <xsl:message> + [DEBUG] constructTopic: bodyType="<xsl:value-of select="$bodyType"/>"</xsl:message>
      <xsl:message> + [DEBUG] constructTopic: prologType="<xsl:value-of select="$prologType"/>"</xsl:message>
      <xsl:message> + [DEBUG] constructTopic: initialSectionType="<xsl:value-of select="$initialSectionType"/>"</xsl:message>
    </xsl:if>
    
    <xsl:variable name="titleIndexEntries" as="element()*">
      <xsl:if test="local:isTopicTitle($firstP)">
        <xsl:sequence select="$firstP//rsiwp:indexterm"/>
      </xsl:if>
    </xsl:variable>
    
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] constructTopic: Creating topic element <xsl:value-of select="$topicType"/></xsl:message>
      <xsl:message> + [DEBUG] constructTopic: topicName="<xsl:sequence select="$topicName"/>"</xsl:message>
    </xsl:if>
    
    <xsl:if test="false() or $debugBoolean">
      <xsl:message> + [DEBUG] constructTopic: schemaAtts=<xsl:sequence select="$schemaAtts"/></xsl:message>
    </xsl:if>
    <xsl:element name="{$topicType}">
      <xsl:attribute name="id" select="$topicName"/>
      <xsl:call-template name="generateXtrcAtt"/>
      <xsl:attribute name="isTopic" select="'true'"/>      
      <xsl:attribute name="xml:lang" select="$language"/>
      <!-- Indicate that this element is in fact a topic as there's no other way
           to know this during the result document processing phase.
        -->
      <xsl:attribute name="isTopic" select="'true'"/>
      <xsl:sequence select="$schemaAtts"/>
      <xsl:if test="$firstP/@topicOutputclass">
        <xsl:attribute name="outputclass" select="$firstP/@topicOutputclass"/>
      </xsl:if>
      <xsl:variable name="titleTagName" as="xs:string"
        select="if ($firstP/@tagName)
        then $firstP/@tagName
        else 'title'
        "
      />
      <xsl:if test="$debugBoolean">
        <xsl:message> + [DEBUG] constructTopic: Applying templates to firstP...</xsl:message>
      </xsl:if>      
      <xsl:apply-templates select="$firstP"/>
      <xsl:if test="$debugBoolean">
        <xsl:message> + [DEBUG] constructTopic: For-each-group on content...</xsl:message>
      </xsl:if>      
      <xsl:for-each-group select="$content[position() > 1]" 
        group-starting-with="*[string(@structureType) = 'topicTitle' and string(@level) = string($nextLevel)]">
        <xsl:if test="false() and $debugBoolean">
          <xsl:message> + [DEBUG] constructTopic: currentGroup[<xsl:sequence select="position()"/>]: <xsl:sequence select="current-group()"/></xsl:message>
        </xsl:if>      
        <xsl:choose>
            <xsl:when test="current-group()[position() = 1] and current-group()[1][string(@structureType) != 'topicTitle']">
              <!-- Prolog and body elements for the topic -->
            <!-- NOTE: can't process title itself here because we're using title elements to define
              topic boundaries.
            -->
            <xsl:apply-templates select="current-group()[string(@topicZone) = 'titleAlts']"/>        
            <xsl:apply-templates select="current-group()[string(@topicZone) = 'shortdesc']"/>             
            <xsl:if test=".[string(@topicZone) = 'prolog' or $level = 0] or count($titleIndexEntries) > 0">
              <xsl:choose>
                <xsl:when test="$level = 0">
                  <xsl:element name="{$prologType}">
                    <xsl:call-template name="generateXtrcAtt"/>
                    <!-- For root topic, can pull metadata from anywhere in the incoming document. -->
                    <xsl:apply-templates select="root($firstP)//*[string(@containingTopic) = 'root' and 
                      string(@topicZone) = 'prolog' and 
                      contains(@baseClass, ' topic/author ')]"/>     
                    <!-- FIXME: This is a hack to handle index entries in keywords. Need to refine this
                                so it handles keywords explicitly mapped to the prolog.
                      -->
                    <xsl:if test="count($titleIndexEntries) > 0">
                      <metadata>
                        <keywords>
                           <xsl:apply-templates select="$titleIndexEntries" mode="p-content"/>                          
                        </keywords>
                      </metadata>
                    </xsl:if>
                    <xsl:apply-templates select="root($firstP)//*[string(@containingTopic) = 'root' and 
                      string(@topicZone) = 'prolog' and 
                      contains(@baseClass, ' topic/data ')
                      ]"/>                        
                  </xsl:element>                  
                </xsl:when>
                <xsl:when test="current-group()[string(@topicZone) = 'prolog' and not(@containingTopic)]">
                  <xsl:element name="{$prologType}">
                    <xsl:call-template name="generateXtrcAtt"/>
                    <xsl:apply-templates select="current-group()[not(@containingTopic) and string(@topicZone) = 'prolog']"/>
                  </xsl:element>
                </xsl:when>
                <xsl:when test="count($titleIndexEntries) > 0">
                  <xsl:element name="{$prologType}">
                    <xsl:call-template name="generateXtrcAtt"/>
                    <metadata>
                      <keywords>
                        <xsl:apply-templates select="$titleIndexEntries" mode="p-content"/>                          
                      </keywords>
                    </metadata>
                  </xsl:element>
                </xsl:when>
                <xsl:otherwise/><!-- Must be only root-level prolog elements in this non-root topic context -->
              </xsl:choose>
            </xsl:if>
            <xsl:if test="current-group()[string(@topicZone) = 'body']">
              <xsl:if test="$debugBoolean">        
                <xsl:message> + [DEBUG] current group is topicZone body</xsl:message>
              </xsl:if>
              <xsl:element name="{$bodyType}">
                <xsl:call-template name="generateXtrcAtt"/>
                <xsl:call-template name="handleSectionParas">
                  <xsl:with-param name="sectionParas" select="current-group()[string(@topicZone) = 'body']" as="element()*"/>
                  <xsl:with-param name="initialSectionType" select="$initialSectionType" as="xs:string"/>
                </xsl:call-template>
              </xsl:element>                  
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:if test="$debugBoolean">        
              <xsl:message> + [DEBUG] makeTopic(): Not topicZone prolog or body, calling makeTopic...</xsl:message>
            </xsl:if>
            <xsl:call-template name="makeTopic">
              <xsl:with-param name="content" select="current-group()" as="node()*"/>
              <xsl:with-param name="level" select="$level + 1" as="xs:integer"/>
              <xsl:with-param name="treePos" select="($treePos, position() - 1)" as="xs:integer+" tunnel="yes"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>        
      </xsl:for-each-group>
    </xsl:element>      
  </xsl:template>
  
  <xsl:template name="handleSectionParas">
    <xsl:param name="sectionParas" as="element()*"/>
    <xsl:param name="initialSectionType" as="xs:string"/>
    
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] handleSectionParas: initialSectionType="<xsl:sequence select="$initialSectionType"/>"</xsl:message>
    </xsl:if>
    <xsl:for-each-group select="$sectionParas" group-starting-with="*[string(@structureType) = 'section']">
      <xsl:choose>
        <xsl:when test="current-group()[position() = 1] and string(@structureType) != 'section'">
          <xsl:choose>
            <xsl:when test="$initialSectionType != ''">
              <xsl:element name="{$initialSectionType}">
                <xsl:call-template name="generateXtrcAtt"/>
                <xsl:call-template name="handleBodyParas">
                  <xsl:with-param name="bodyParas" select="current-group()"/>
                </xsl:call-template>
              </xsl:element>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="handleBodyParas">
                <xsl:with-param name="bodyParas" select="current-group()"/>
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>
          
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="sectionType" as="xs:string"
              select="if (@sectionType) then string(@sectionType) else 'section'"
          />
          <xsl:element name="{$sectionType}">
            <xsl:call-template name="generateXtrcAtt"/>
            <xsl:if test="@spectitle != ''">
              <xsl:variable name="spectitle" select="local:constructSpectitle(.)" as="xs:string"/>
              <xsl:attribute name="spectitle" select="$spectitle"/>
            </xsl:if>
            <xsl:variable name="firstSectionPara" as="element()">
              <xsl:choose>
                <xsl:when test="starts-with(@spectitle, '#')">
                  <xsl:sequence select="local:removeSpectitleContent(.)"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:sequence select="current-group()[1]"/>
                </xsl:otherwise>
              </xsl:choose>
              
            </xsl:variable>
            <xsl:variable name="bodyParas"
              select="if (string(@useAsTitle) = 'no' or 
                          ((@spectitle != '') and 
                           (not(starts-with(@spectitle, '#')))))
                         then current-group()[position() > 1]
                         else ($firstSectionPara, current-group()[position() > 1])                         
              "
            />
            <xsl:call-template name="handleBodyParas">
              <xsl:with-param name="bodyParas" select="$bodyParas"/>
            </xsl:call-template>
          </xsl:element>
        </xsl:otherwise>
      </xsl:choose>      
    </xsl:for-each-group>
  </xsl:template>
  
  <xsl:template name="handleBodyParas">
    <xsl:param name="bodyParas" as="element()*"/>
    
    <xsl:for-each-group select="$bodyParas" group-adjacent="boolean(@containerType)">
      <xsl:choose>
        <xsl:when test="@containerType">
          <xsl:variable name="containerGroup" as="element()">
            <containerGroup containerType="{@containerType}">
              <xsl:sequence select="current-group()"/>
            </containerGroup>
          </xsl:variable>
          <xsl:apply-templates select="$containerGroup"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="current-group()"/>
        </xsl:otherwise>
      </xsl:choose>
      
    </xsl:for-each-group>
  </xsl:template>
  
  <xsl:template match="containerGroup">
<!--    <xsl:message> + [DEBUG] Handling groupContainer...</xsl:message>-->
    <xsl:call-template name="processLevelNContainers">
      <xsl:with-param name="context" select="*" as="element()*"/>
      <xsl:with-param name="level" select="1" as="xs:integer"/>
      <xsl:with-param name="currentContainer" select="'body'" as="xs:string"/>
    </xsl:call-template>    
  </xsl:template>
  
  <xsl:template name="generateXtrcAtt">
    <xsl:if test="$includeWordBackPointersBoolean">
      <xsl:attribute name="xtrc" select="@wordLocation"/>
    </xsl:if>    
  </xsl:template>
  
  <xsl:template name="processLevelNContainers">
    <xsl:param name="context" as="element()*"/>
    <xsl:param name="level" as="xs:integer"/>
    <xsl:param name="currentContainer" as="xs:string"/>
<!--    <xsl:message> + [DEBUG] processLevelNContainers, level="<xsl:sequence select="$level"/>"</xsl:message>
    <xsl:message> + [DEBUG]   currentContainer="<xsl:sequence select="$currentContainer"/>"</xsl:message>
-->    
    <xsl:for-each-group select="$context[@level = $level]" group-adjacent="@containerType">
<!--      <xsl:message> + [DEBUG]   @containerType="<xsl:sequence select="string(@containerType)"/>"</xsl:message>
      <xsl:message> + [DEBUG]   $currentContainer != @containerType="<xsl:sequence select="$currentContainer != string(@containerType)"/>"</xsl:message>
-->
      <xsl:choose>
        <xsl:when test="$currentContainer != string(@containerType)">
<!--          <xsl:message> + [DEBUG ]  currentContainer != @containerType, currentPara=<xsl:sequence select="local:reportPara(.)"/></xsl:message>-->
          <xsl:element name="{@containerType}">
            <xsl:call-template name="generateXtrcAtt"/>
            <xsl:if test="@containerOutputclass">
              <xsl:attribute name="outputclass" select="string(@containerOutputclass)"/>
            </xsl:if>
            <xsl:for-each select="current-group()">
              <xsl:call-template name="handleGroupSequence">
                <xsl:with-param name="level" select="$level" as="xs:integer"/>
              </xsl:call-template>
            </xsl:for-each>
          </xsl:element>
        </xsl:when>
        <xsl:otherwise>
          <xsl:for-each select="current-group()">
            <xsl:call-template name="handleGroupSequence">
              <xsl:with-param name="level" select="$level" as="xs:integer"/>
            </xsl:call-template>
          </xsl:for-each>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each-group>    
  </xsl:template>
  <xsl:template name="handleGroupSequence">
    <xsl:param name="level" as="xs:integer"/>
    <xsl:choose>
      <xsl:when test="string(@structureType) = 'dt' and @level = $level">
        <xsl:variable name="dlEntryType" as="xs:string"
          select="if (@dlEntryType) then string(@dlEntryType) else 'dlentry'"
        />
        <xsl:element name="{$dlEntryType}"> 
          <xsl:call-template name="generateXtrcAtt"/>
          <xsl:call-template name="transformPara"/>
          <xsl:variable name="followingSibling" as="element()?" select="following-sibling::*[1]"/>
          <xsl:variable name="precedingSibling" as="element()?" select="preceding-sibling::*[1]"/>
          <!-- find position of next <dt> element type -->
          <xsl:variable name="followingSiblingDtPositions" as="item()*">
            <xsl:for-each select="following-sibling::*">
              <xsl:if test="@structureType='dt'">
                <xsl:sequence select="position()"/>
              </xsl:if>
            </xsl:for-each>
          </xsl:variable>
          <xsl:variable name="firstFollowingSiblingDtPosition" as="xs:integer">
            <xsl:choose>
              <xsl:when test="following-sibling::*[@structureType='dt']">
                <xsl:value-of select="$followingSiblingDtPositions[position()=1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="0"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="$followingSibling/@level &gt; @level">
              <xsl:for-each-group select="following-sibling::*" group-adjacent="@level">
                <xsl:if test="@level &gt; $level">
                  <xsl:element name="{@containerType}">
                    <xsl:call-template name="generateXtrcAtt"/>
                    
                  <xsl:for-each select="current-group()">
                    <xsl:choose>
                      <xsl:when test="string(@structureType) = 'dt'">
                        <xsl:variable name="nestedFollowingSibling" as="element()?" select="following-sibling::*[1]"/>
                        <xsl:variable name="dlEntryType" as="xs:string"
                          select="if (@dlEntryType) then string(@dlEntryType) else 'dlentry'"
                        />
                        <xsl:element name="{$dlEntryType}">  
                          <xsl:call-template name="generateXtrcAtt"/>
                          <xsl:call-template name="transformPara"/>
                          <!-- find position of next <dt> element type -->
                          <xsl:variable name="followingNestedSiblingDtPositions" as="item()*">
                            <xsl:for-each select="following-sibling::*">
                              <xsl:if test="@structureType='dt'">
                                <xsl:sequence select="position()"/>
                              </xsl:if>
                            </xsl:for-each>
                          </xsl:variable>
                          <xsl:variable name="firstFollowingNestedSiblingDtPosition" as="xs:integer">
                            <xsl:choose>
                              <xsl:when test="following-sibling::*[@structureType='dt']">
                                <xsl:value-of select="$followingNestedSiblingDtPositions[position()=1]"/>
                              </xsl:when>
                              <xsl:otherwise>
                                <xsl:value-of select="0"/>
                              </xsl:otherwise>
                            </xsl:choose>
                          </xsl:variable>
                          <xsl:choose>
                            <xsl:when test="following-sibling::*[@structureType='dt']">
                              <xsl:for-each select="following-sibling::*[@structureType='dd'][position() &lt; $firstFollowingNestedSiblingDtPosition]">
                                <xsl:call-template name="transformPara"/>
                              </xsl:for-each>
                            </xsl:when>
                            <xsl:otherwise>
                              <xsl:for-each select="$nestedFollowingSibling">
                                <xsl:call-template name="transformPara"/>
                              </xsl:for-each>
                            </xsl:otherwise>
                          </xsl:choose>
                          <!-- 
                          <xsl:for-each select="$nestedFollowingSibling">
                            <xsl:call-template name="transformPara"/>
                          </xsl:for-each>
                          -->
                        </xsl:element>
                      </xsl:when>
                    </xsl:choose>
                  </xsl:for-each>
                </xsl:element>
                </xsl:if>
              </xsl:for-each-group>
            </xsl:when>
            <xsl:when test="$precedingSibling/@level &lt; @level"/>
              <xsl:otherwise>
                <xsl:choose>
                  <xsl:when test="following-sibling::*[@structureType='dt']">
                    <xsl:for-each select="following-sibling::*[@structureType='dd'][position() &lt; $firstFollowingSiblingDtPosition]">
                      <xsl:call-template name="transformPara"/>
                    </xsl:for-each>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:for-each select="following-sibling::*[@structureType='dd']">
                      <xsl:call-template name="transformPara"/>
                    </xsl:for-each>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:otherwise>
          </xsl:choose>
        </xsl:element>
      </xsl:when>
      <xsl:when test="string(@structureType) = 'dd'"/><!-- Handled by dt processing -->
     <xsl:when test="following-sibling::*[1][@level &gt; $level]">
        <xsl:variable name="me" select="." as="element()"/>
       <xsl:element name="{@tagName}">  
         <xsl:call-template name="generateXtrcAtt"/>
         <xsl:apply-templates select="rsiwp:bookmarkStart" mode="generate-para-ids">
           <xsl:with-param name="tagName" select="@tagName" as="xs:string"/>
         </xsl:apply-templates>
         <xsl:call-template name="transformParaContent"/>
          <xsl:call-template name="processLevelNContainers">
            <xsl:with-param name="context" 
              select="following-sibling::*[(@level = $level + 1) and 
              preceding-sibling::*[@level = $level][1][. is $me]]" as="element()*"/>
            <xsl:with-param name="level" select="$level + 1" as="xs:integer"/>
            <xsl:with-param name="currentContainer" select="@tagName" as="xs:string"/>
          </xsl:call-template>
        </xsl:element>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="transformPara"/>
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:template>
  
  <xsl:template mode="generate-para-ids" match="rsiwp:bookmarkStart">
    <xsl:param name="tagName" as="xs:string" select="../@tagName"/>
    <xsl:attribute name="id" select="concat($tagName, '_', @name)"/>
  </xsl:template>
  
  <xsl:template match="rsiwp:break" mode="p-content">
    <br/>
  </xsl:template>
  
  <xsl:template match="rsiwp:tab" mode="p-content">
    <tab/>
  </xsl:template>
  
  <xsl:template match="rsiwp:b | 
    rsiwp:i | 
    rsiwp:u | 
    rsiwp:sup | 
    rsiwp:sub | 
    rsiwp:ph 
    "
    mode="p-content">
    <xsl:element name="{local-name()}">
      <xsl:sequence select="./@*"/>
      <xsl:apply-templates mode="p-content"/>
    </xsl:element>
  </xsl:template>
  
  <xsl:template mode="p-content" match="rsiwp:bookmarkStart">
    <xsl:if test="$includeWordBookmarksBoolean">
      <data name="bookmarkStart" value="{@name}" id="bookmark_{@id}">
      </data>
    </xsl:if>
  </xsl:template>
  
  <xsl:template mode="p-content" match="rsiwp:bookmarkEnd">
    <xsl:if test="$includeWordBookmarksBoolean">
      <data name="bookmarkEnd" value="bookmark_{@id}"/>
    </xsl:if>
  </xsl:template>
  
  <xsl:template match="rsiwp:indexterm" mode="p-content">
    <xsl:param name="inTitleContext" as="xs:boolean" tunnel="yes"
       select="false()"/>
    <xsl:if test="not($inTitleContext)">
      <xsl:element name="{local-name()}">
        <xsl:sequence select="./@*"/>
        <xsl:apply-templates mode="p-content"/>
      </xsl:element>
    </xsl:if>
  </xsl:template>
  
  <xsl:template match="rsiwp:fn" mode="p-content">
    <xsl:element name="{local-name()}">
      <xsl:sequence select="./@*"/>
      <xsl:call-template name="handleSectionParas">
        <xsl:with-param name="sectionParas" select="*" as="element()*"/>
        <xsl:with-param name="initialSectionType" as="xs:string" select="''"/>        
      </xsl:call-template>
    </xsl:element>
  </xsl:template>
  
  <xsl:template match="rsiwp:hyperlink" mode="p-content">
    
    <xsl:param name="simpleWpDoc" as="document-node()" tunnel="yes"
    />            
    
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] rsiwp:hyperlink: structureType="<xsl:sequence select="string(@structureType)"/>"</xsl:message>
    </xsl:if>
    <xsl:variable name="tagName" as="xs:string"
      select="if (@tagName) then string(@tagName) else 'xref'"
    />
    <xsl:element name="{$tagName}">
      <!-- Not all Word hyperlinks become DITA hyperlinks: -->
      <xsl:if test="string(@structureType) = 'xref'">
        <xsl:variable name="origHref" select="@href" as="xs:string"/>
        <xsl:variable name="href" as="xs:string">
          <xsl:choose>
            <xsl:when test="matches($origHref, '^\w+:')">
              <!-- URI of some sort, assume external scope -->
              <xsl:sequence select="$origHref"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="local:bookmarkRefToDitaRef(., $simpleWpDoc)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="scope" as="xs:string?">
          <xsl:choose>
            <xsl:when test="matches($origHref, '^\w+:')">
              <xsl:sequence select="'external'"/>
            </xsl:when>
            <xsl:otherwise>
              <!-- scope is defaulted  -->
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="format" as="xs:string?">
          <xsl:choose>
            <xsl:when test="matches($origHref, '^\w+:')">
              <xsl:variable name="extension" select="relpath:getExtension($origHref)"/>
              <xsl:choose>
                <xsl:when test="$extension = ('htm', 'html', 'pgp')">
                  <!-- FIXME: Add to the list of extensions that indicate HTML format -->
                  <xsl:sequence select="'html'"/>
                </xsl:when>
                <xsl:when test="(starts-with($origHref, 'http:') or 
                                 starts-with($origHref, 'https:'))">
                  <!-- If the scheme is HTTP or HTTPS then if there
                       is no extension assum "html" otherwise use the 
                       extension of the resource.
                    -->
                  <xsl:choose>
                    <xsl:when test="$extension = ''">
                      <xsl:sequence select="'html'"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:sequence select="$extension"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                  <!-- Use the URI scheme as the format, since that will usually be
                       correct (e.g., mailto, ftp, etc.)
                    -->
                  <xsl:variable name="scheme" 
                    select="if (starts-with($origHref, 'urn:'))
                               then substring-before(substring-after($origHref, 'urn:'), ':')
                               else substring-before($origHref, ':')
                    "/>
                  <xsl:message> + [DEBUG] rsiwp:hyperlink: scheme="<xsl:sequence select="$scheme"/>"</xsl:message>
                  <xsl:sequence select="$scheme"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <!-- Format is unspecified -->
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:attribute name="href" select="$href"/>
        <xsl:if test="$scope">
          <xsl:attribute name="scope" select="$scope"/>
        </xsl:if>
        <xsl:if test="$format">
          <xsl:attribute name="format" select="$format"/>
        </xsl:if>
      </xsl:if>
      <xsl:apply-templates mode="#current"/>
    </xsl:element>
  </xsl:template>
  
  <xd:doc xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl">
    <xd:desc>
      <xd:p>Generates a DITA image element. The URL of the image is determined
      by creating a relative path constructed from the value of the @src
      attribute in the simple WP, which should point to the absolute
      location of the image as it will be accessed by the generated XML,
      and the directory containing the result file for the
      topic being generated, so the resulting value is a relative
      path from the containing topic document to the image.</xd:p>
    </xd:desc>
    <xd:param name="resultUrl"></xd:param>
  </xd:doc>
  <xsl:template match="rsiwp:image" mode="p-content">
    <xsl:param name="resultUrl" as="xs:string" tunnel="yes"/>
    
    <xsl:variable name="resultDir" select="relpath:getParent($resultUrl)"/>
    <xsl:variable name="srcAtt" select="@src" as="xs:string"/>
    <xsl:variable name="imageUrl" as="xs:string"
      select="relpath:getRelativePath($resultDir, $srcAtt)"
    />
    <image href="{$imageUrl}">
      <alt><xsl:sequence select="$imageUrl"/></alt>
    </image>
  </xsl:template>
  
  <xsl:function name="local:isMap" as="xs:boolean">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleName" as="xs:string"
      select="$context/@style"
    />
    <xsl:choose>
      <xsl:when test="$styleName = '' or $styleName = '[None]'">
        <xsl:sequence select="false()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()?"
          select="(key('styleMapsByName', lower-case($styleName), $styleMapDoc)[1],
          key('styleMapsById', $styleName, $styleMapDoc))[1]"
        />
        <xsl:sequence
          select="
          if ($styleMap)
          then ($styleMap/string(@structureType) = 'map' or
                $styleMap/string(@structureType) = 'mapTitle')
          else false()
          "
        />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>
  
  <xsl:function name="local:isMapRoot" as="xs:boolean">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleName" as="xs:string"
      select="$context/@style"
    />
    <xsl:choose>
      <xsl:when test="$styleName = '' or $styleName = '[None]'">
        <xsl:sequence select="false()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()?"
          select="(key('styleMapsByName', lower-case($styleName), $styleMapDoc)[1],
          key('styleMapsById', $styleName, $styleMapDoc))[1]"
        />
        <xsl:sequence
          select="
          if ($styleMap)
          then string($styleMap/@structureType) = 'map'
          else false()
          "
        />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>
  
  <xsl:function name="local:isMapTitle" as="xs:boolean">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleName" as="xs:string"
      select="$context/@style"
    />
    <xsl:choose>
      <xsl:when test="$styleName = '' or $styleName = '[None]'">
        <xsl:sequence select="false()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()?"
          select="(key('styleMapsByName', lower-case($styleName), $styleMapDoc)[1],
          key('styleMapsById', $styleName, $styleMapDoc))[1]"
        />
        <xsl:sequence
          select="
          if ($styleMap)
          then string($styleMap/@structureType) = 'mapTitle'
          else false()
          "
        />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>
  
  <xsl:function name="local:isRootTopicTitle" as="xs:boolean">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleName" as="xs:string"
      select="$context/@style"
    />
    <xsl:choose>
      <xsl:when test="$styleName = '' or $styleName = '[None]'">
        <xsl:sequence select="false()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()?"
          select="
          (key('styleMapsByName', lower-case($styleName), $styleMapDoc)[1],
          key('styleMapsById', $styleName, $styleMapDoc))[1]"
        />
        <xsl:sequence
          select="
          if ($styleMap)
          then (($styleMap/@level = '0') and ($styleMap/@structureType = 'topicTitle'))
          else false()
          "
        />
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:function>
  
  <xsl:function name="local:isTopicTitle" as="xs:boolean">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleId" as="xs:string"
      select="$context/@style"
    />
    <xsl:choose>
      <xsl:when test="not($styleId) or $styleId = '' or $styleId = '[None]'">
        <xsl:sequence select="false()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()?"
          select="
          (key('styleMapsByName', lower-case($styleId), $styleMapDoc)[1],
          key('styleMapsById', $styleId, $styleMapDoc)[1])[1]"
        />
        <xsl:sequence
          select="
          if ($styleMap)
          then $styleMap/@structureType = 'topicTitle'
          else false()
          "
        />
      </xsl:otherwise>
    </xsl:choose>    
  </xsl:function>
  
  <xsl:function name="local:getTopicType" as="xs:string">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleId" as="xs:string"
      select="$context/@style"
    />
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] local:getTopicType(): styleId="<xsl:value-of select="$styleId"/>"</xsl:message>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="$styleId = '' or $styleId = '[None]'">
        <xsl:sequence select="'unknown-topic-type'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()?"
          select="(key('styleMapsByName', lower-case($styleId), $styleMapDoc)[1],
          key('styleMapsById', $styleId, $styleMapDoc)[1])[1]"
        />
        <xsl:if test="$debugBoolean">
          <xsl:message> + [DEBUG] local:getTopicType(): styleMap="<xsl:sequence select="$styleMap"/>"</xsl:message>
        </xsl:if>
        <xsl:variable name="topicType"
          select="
          if ($styleMap and $styleMap/@topicType)
          then string($styleMap/@topicType)
          else 'unknown-topic-type'
          "
          as="xs:string"
        />
        <xsl:if test="$debugBoolean">
          <xsl:message> + [DEBUG] local:getTopicType(): returning "<xsl:value-of select="$topicType"/>"</xsl:message>
        </xsl:if>
        <xsl:sequence select="$topicType"/>
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:function>

  <xsl:function name="local:getMapType" as="xs:string">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="styleId" as="xs:string"
      select="$context/@style"
    />
    <xsl:choose>
      <xsl:when test="$styleId = '' or $styleId = '[None]'">
        <xsl:sequence select="'unknown-map-type'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="styleMap" as="element()?"
          select="(key('styleMapsByName', lower-case($styleId), $styleMapDoc)[1],
          key('styleMapsById', $styleId, $styleMapDoc)[1])[1]"
        />
        <xsl:sequence
          select="
          if ($styleMap and $styleMap/@mapType)
          then string($styleMap/@mapType)
          else 'unknown-map-type'
          "
        />
      </xsl:otherwise>
    </xsl:choose>
    
  </xsl:function>
  
  <xsl:function name="local:getResultUrlForTopic" as="xs:string">
    <xsl:param name="context" as="element()"/>
    <xsl:param name="topicrefType" as="xs:string?"/>
    <xsl:param name="treePos" as="xs:integer+"/>
    <xsl:param name="mapUrl" as="xs:string"/>
    <xsl:param name="topicName" as="xs:string"/>
    
    <xsl:if test="false() or $debugBoolean">
      <xsl:message> + [DEBUG] getResultUrlForTopic(): topicrefType=<xsl:value-of select="$topicrefType"/>, treePos=<xsl:value-of select="$treePos"/></xsl:message>
    </xsl:if>
    <xsl:variable name="topicRelativeUri" as="xs:string+">
      <xsl:apply-templates mode="topic-url" select="$context">
        <xsl:with-param name="topicrefType" as="xs:string?" select="$topicrefType"/>
        <xsl:with-param name="treePos" as="xs:integer+" select="$treePos"/>   
        <xsl:with-param name="topicName" as="xs:string" select="$topicName"/>   
      </xsl:apply-templates>
    </xsl:variable>
    <!-- mapUrl is the URL of the map document -->
    <xsl:variable name="parentDir" select="relpath:getParent($mapUrl)" as="xs:string"/>
    <xsl:variable name="result" as="xs:string"
      select="relpath:newFile($parentDir, $topicRelativeUri)"
    />
    <xsl:sequence select="$result"/>
  </xsl:function>

  <xsl:function name="local:getResultUrlForMap" as="xs:string">
    <xsl:param name="context" as="element()"/>
    <xsl:param name="topicrefType" as="xs:string"/>
    <xsl:param name="treePos" as="xs:integer+"/>
    <xsl:param name="parentMapUrl" as="xs:string"/>
    
    <xsl:variable name="mapRelativeUri" as="xs:string+">
      <xsl:apply-templates mode="map-url" select="$context">
        <xsl:with-param name="topicrefType" as="xs:string" select="$topicrefType"/>
        <xsl:with-param name="treePos" as="xs:integer+" select="$treePos"/>        
      </xsl:apply-templates>
    </xsl:variable>
    <xsl:variable name="result" as="xs:string"
      select="relpath:newFile(relpath:getParent($parentMapUrl), string-join($mapRelativeUri, ''))"
    />
    <xsl:sequence select="$result"/>
  </xsl:function>

  <xsl:template match="rsiwp:p" mode="topic-name">
    <!-- Generates the name for a topic, which can then be
         used in IDs and filenames.
      -->
    <xsl:param name="treePos" as="xs:integer+"/>
    <xsl:variable name="treePosString" as="xs:string+">
      <xsl:for-each select="$treePos">
        <xsl:value-of select="concat('_', .)"/>
      </xsl:for-each>
    </xsl:variable>

    <xsl:variable name="result" select="concat($fileNamePrefix, 'topic', string-join($treePosString, ''))"/>
    <xsl:sequence select="$result"/>
    
  </xsl:template>  
 
  <xsl:template match="rsiwp:p" mode="topic-url">   
    <xsl:param name="treePos" as="xs:integer+"/>
    <xsl:param name="topicName" as="xs:string"/>
    
    <xsl:if test="false() or $debugBoolean">
      <xsl:message> + [DEBUG] rsiwp:p, mode=topic-url: treePos=<xsl:sequence select="$treePos"/></xsl:message>
    </xsl:if>

    <xsl:variable name="result" select="concat('topics/', $topicName, $topicExtension)"/>
    <xsl:if test="false() or $debugBoolean">
      <xsl:message> + [DEBUG] rsiwp:p, mode=topic-url: result="<xsl:sequence select="$result"/>"</xsl:message>
    </xsl:if>
    <xsl:sequence select="$result"/>
  </xsl:template>
  
  <xsl:template match="text()" mode="map-url topic-url"/>   
  
 
  <xsl:template match="rsiwp:p" mode="map-url">   
    <xsl:param name="treePos" as="xs:integer+"/>
    
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] rsiwp:p, mode=map-url: treePos=<xsl:sequence select="$treePos"/></xsl:message>
    </xsl:if>
    
    <xsl:variable name="treePosString" as="xs:string+">
      <xsl:for-each select="$treePos">
        <xsl:value-of select="concat('_', .)"/>
      </xsl:for-each>
    </xsl:variable>
    
    <xsl:variable name="submapName" as="xs:string" select="concat($fileNamePrefix, $submapNamePrefix, string-join($treePosString, ''))"/>
    
    <xsl:variable name="result" select="concat($submapName, '/', $submapName, '.ditamap')"/>
    <xsl:if test="$debugBoolean">
      <xsl:message> + [DEBUG] rsiwp:p, mode="map-url": result=<xsl:sequence select="$result"/></xsl:message>
    </xsl:if>
    <xsl:sequence select="$result"/>
  </xsl:template>
  
  <xsl:template match="rsiwp:*" mode="topic-url">
    <xsl:message> - [WARNING] Unhandled element <xsl:sequence select="name(..)"/>/<xsl:sequence select="name(.)"/> in mode 'topic-url'</xsl:message>
    <xsl:variable name="topicTitleFragment">
      <xsl:choose>
        <xsl:when test="contains(.,' ')">
          <xsl:value-of select="replace(substring-before(.,' '),'[\p{P}\p{Z}\p{C}]','')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="replace(.,'[\p{P}\p{Z}\p{C}]','')"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:sequence select="concat('topics/topic_', $topicTitleFragment, '_', generate-id(.),format-time(current-time(),'[h][m][s]'), '.dita')"/>
  </xsl:template>
  
  <xsl:template match="rsiwp:*" mode="map-url">
    <xsl:message> - [WARNING] Unhandled element <xsl:sequence select="name(..)"/>/<xsl:sequence select="name(.)"/> in mode 'map-url'</xsl:message>
    <xsl:variable name="mapTitleFragment">
      <xsl:choose>
        <xsl:when test="contains(.,' ')">
          <xsl:value-of select="replace(substring-before(.,' '),'[\p{P}\p{Z}\p{C}]','')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="replace(.,'[\p{P}\p{Z}\p{C}]','')"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:sequence select="concat('topics/topic_', $mapTitleFragment, '_', generate-id(.), $topicExtension)"/>
  </xsl:template>
  
  
  <xsl:function name="local:debugMessage">
    <xsl:param name="msg" as="xs:string"/>
    <xsl:message> + [DEBUG] <xsl:sequence select="$msg"/></xsl:message>
  </xsl:function>
  
  <xsl:function name="local:reportParas">
    <xsl:param name="paras" as="element()*"/>
    <xsl:for-each select="$paras">
      <xsl:sequence select="local:reportPara(.)"/>
      <xsl:text>&#x0a;</xsl:text>
    </xsl:for-each>
  </xsl:function>
  
  <xsl:function name="local:reportPara">
    <xsl:param name="para" as="element()?"/>
    <xsl:if test="$para">
      <xsl:sequence 
        select="concat('[', 
                       name($para),
                       ' ',
                       ' tagName=',
                       $para/@tagName,
                       if ($para/@level)
                          then concat(' level=', $para/@level)
                          else '',
                       if ($para/@containerType)
                          then concat(' containerType=', $para/@containerType)
                          else '',
                       if ($para/@containerOutputclass)
                          then concat(' containerOutputclass=', $para/@containerOutputclass)
                          else '',
                          ']',
                       substring(normalize-space($para), 1,20)
                       )"
      />
    </xsl:if>
  </xsl:function>
 
  <xsl:function name="local:constructSpectitle">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="specTitleSpec" select="string($context/@spectitle)"/>    
    <xsl:variable name="spectitle" as="xs:string">
      <xsl:choose>
        <xsl:when test="$specTitleSpec = '#toColon'">
          <xsl:sequence select="substring-before(string($context), ':')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="string($context/@spectitle)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:sequence select="$spectitle"/>
  </xsl:function>
  
  <xsl:function name="local:removeSpectitleContent" as="element()">
    <xsl:param name="context" as="element()"/>
    <xsl:variable name="initialText" as="xs:string" select="$context/text()[count(preceding-sibling::*) = 0]"/>
    <xsl:element name="{name($context)}"
      namespace="{namespace-uri($context)}"
      >
      <xsl:sequence select="$context/@*"/>
      <xsl:choose>
        <xsl:when test="string($context/@spectitle) = '#toColon'">
          <xsl:sequence select="substring-after($initialText, ': ')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="string($initialText)"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:sequence select="$context/* | $context/text()[count(preceding-sibling::*) gt 0]"/>
    </xsl:element>
  </xsl:function>
  
  <xsl:function name="local:getContainerTypeSiblings" as="node()*">
    <xsl:param name="sibs" as="element()*"/>
    <xsl:variable name="lastSib" select="$sibs[last()]" as="element()"/>
    <xsl:variable name="nextSib" select="$lastSib/following-sibling::*[1]" as="element()?"/>
    <xsl:variable name="containerType" select="$lastSib/@containerType" as="xs:string"/>
    <xsl:choose>
      <xsl:when test="$nextSib[@containerType = $containerType]">
        <xsl:sequence select="local:getContainerTypeSiblings(($sibs, $nextSib))"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$sibs"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>
  
  <xsl:function name="local:bookmarkRefToDitaRef" as="xs:string">
    <!-- Given a Word Hyperlink that is a reference to a bookmark, 
         convert the bookmark reference to a DITA reference (topic ID or topicID/elementId)
         if at all possible.
         
         Note that at the time we process the hyperlink there is no way to know what
         the final ID or location of the target element will be. Thus the best we can
         do here is to use the @wordlocation value as the reference. That will allow
         post processing to find the target by its word location and correct the
         href value to the appropriate URL and fragment identifier.
      -->
    <xsl:param name="hyperlinkElem" as="element()"/><!-- The SimpleML hyperlink element -->
    <xsl:param name="simpleWpDoc" as="document-node()"/>            
    

    <xsl:variable name="bookmarkName" as="xs:string" select="$hyperlinkElem/@href"/>
    <xsl:variable name="bookmark" select="key('bookmarksByName', $hyperlinkElem/@href, $simpleWpDoc)"/>
<!--    <xsl:message> + [DEBUG] + bookmarkRefToDitaRef(): bookmark=<xsl:sequence select="$bookmark"/></xsl:message>-->
    <xsl:variable name="targetPara" as="element()?"
      select="$bookmark/ancestor::rsiwp:p[1]
      "
    />
<!--    <xsl:message> + [DEBUG] + bookmarkRefToDitaRef(): targetPara=<xsl:sequence select="$targetPara"/></xsl:message>-->
    <xsl:choose>
      <xsl:when test="$targetPara">
        <xsl:sequence select="concat('urn:wordlocation:', $targetPara/@wordLocation)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="concat('unresolvable reference to name ', $hyperlinkElem/@href)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>
  
  <xsl:template match="rsiwp:*" priority="-0.5" mode="p-content">
    <xsl:message> + [WARNING] simple2dita[p-content]: Unhandled element <xsl:sequence select="name(..)"/>/<xsl:sequence select="name(.)"/></xsl:message>
  </xsl:template>
  
  <xsl:template match="rsiwp:*" priority="-0.5">
    <xsl:message> + [WARNING] simple2dita: Unhandled element <xsl:sequence select="name(..)"/>/<xsl:sequence select="name(.)"/></xsl:message>
  </xsl:template>

</xsl:stylesheet>
